(* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT BY HAND! *)

module type S = sig
  type t
  type scalar

  val abs :
    t ->
    t

  val abs_ :
    t ->
    t

  val abs_out :
    t ->
    t ->
    t

  val acos :
    t ->
    t

  val acos_ :
    t ->
    t

  val acos_out :
    t ->
    t ->
    t

  val adaptive_avg_pool1d :
    t ->
    int list ->
    t

  val adaptive_avg_pool2d :
    t ->
    int list ->
    t

  val adaptive_avg_pool2d_backward :
    t ->
    t ->
    t

  val adaptive_avg_pool2d_backward_out :
    t ->
    t ->
    t ->
    t

  val adaptive_avg_pool2d_forward :
    t ->
    int list ->
    t

  val adaptive_avg_pool2d_forward_out :
    t ->
    t ->
    int list ->
    t

  val adaptive_avg_pool2d_out :
    t ->
    t ->
    int list ->
    t

  val adaptive_avg_pool3d :
    t ->
    int list ->
    t

  val adaptive_avg_pool3d_backward :
    t ->
    t ->
    t

  val adaptive_avg_pool3d_backward_out :
    t ->
    t ->
    t ->
    t

  val adaptive_avg_pool3d_forward :
    t ->
    int list ->
    t

  val adaptive_avg_pool3d_forward_out :
    t ->
    t ->
    int list ->
    t

  val adaptive_avg_pool3d_out :
    t ->
    t ->
    int list ->
    t

  val adaptive_max_pool2d_backward :
    t ->
    t ->
    t ->
    t

  val adaptive_max_pool2d_backward_out :
    t ->
    t ->
    t ->
    t ->
    t

  val adaptive_max_pool3d_backward :
    t ->
    t ->
    t ->
    t

  val adaptive_max_pool3d_backward_out :
    t ->
    t ->
    t ->
    t ->
    t

  val add :
    t ->
    t ->
    t

  val add1 :
    t ->
    scalar ->
    t

  val add_ :
    t ->
    t ->
    t

  val add_1 :
    t ->
    scalar ->
    t

  val add_out :
    t ->
    t ->
    t ->
    t

  val addbmm :
    t ->
    t ->
    t ->
    t

  val addbmm_ :
    t ->
    t ->
    t ->
    t

  val addbmm_out :
    t ->
    t ->
    t ->
    t ->
    t

  val addcdiv :
    t ->
    t ->
    t ->
    t

  val addcdiv_ :
    t ->
    t ->
    t ->
    t

  val addcdiv_out :
    t ->
    t ->
    t ->
    t ->
    t

  val addcmul :
    t ->
    t ->
    t ->
    t

  val addcmul_ :
    t ->
    t ->
    t ->
    t

  val addcmul_out :
    t ->
    t ->
    t ->
    t ->
    t

  val addmm :
    t ->
    t ->
    t ->
    t

  val addmm_ :
    t ->
    t ->
    t ->
    t

  val addmm_out :
    t ->
    t ->
    t ->
    t ->
    t

  val addmv :
    t ->
    t ->
    t ->
    t

  val addmv_ :
    t ->
    t ->
    t ->
    t

  val addmv_out :
    t ->
    t ->
    t ->
    t ->
    t

  val addr :
    t ->
    t ->
    t ->
    t

  val addr_ :
    t ->
    t ->
    t ->
    t

  val addr_out :
    t ->
    t ->
    t ->
    t ->
    t

  val alias :
    t ->
    t

  val all :
    t ->
    int ->
    bool ->
    t

  val all_out :
    t ->
    t ->
    int ->
    bool ->
    t

  val alpha_dropout :
    t ->
    float ->
    bool ->
    t

  val alpha_dropout_ :
    t ->
    float ->
    bool ->
    t

  val any :
    t ->
    int ->
    bool ->
    t

  val any_out :
    t ->
    t ->
    int ->
    bool ->
    t

  val arange1 :
    scalar ->
    scalar ->
    Kind.t * Device.t ->
    t

  val arange2 :
    scalar ->
    scalar ->
    scalar ->
    Kind.t * Device.t ->
    t

  val arange3 :
    scalar ->
    Kind.t * Device.t ->
    t

  val arange_out1 :
    t ->
    scalar ->
    scalar ->
    t

  val arange_out2 :
    t ->
    scalar ->
    scalar ->
    scalar ->
    t

  val arange_out3 :
    t ->
    scalar ->
    t

  val argmax1 :
    t ->
    int ->
    bool ->
    t

  val argmax2 :
    t ->
    t

  val argmin1 :
    t ->
    int ->
    bool ->
    t

  val argmin2 :
    t ->
    t

  val as_strided1 :
    t ->
    int list ->
    int list ->
    t

  val as_strided2 :
    t ->
    int list ->
    int list ->
    int ->
    t

  val as_strided_1 :
    t ->
    int list ->
    int list ->
    t

  val as_strided_2 :
    t ->
    int list ->
    int list ->
    int ->
    t

  val asin :
    t ->
    t

  val asin_ :
    t ->
    t

  val asin_out :
    t ->
    t ->
    t

  val atan :
    t ->
    t

  val atan2 :
    t ->
    t ->
    t

  val atan2_ :
    t ->
    t ->
    t

  val atan2_out :
    t ->
    t ->
    t ->
    t

  val atan_ :
    t ->
    t

  val atan_out :
    t ->
    t ->
    t

  val avg_pool1d :
    t ->
    int list ->
    int list ->
    int list ->
    bool ->
    bool ->
    t

  val avg_pool2d :
    t ->
    int list ->
    int list ->
    int list ->
    bool ->
    bool ->
    t

  val avg_pool2d_backward :
    t ->
    t ->
    int list ->
    int list ->
    int list ->
    bool ->
    bool ->
    t

  val avg_pool2d_backward_out :
    t ->
    t ->
    t ->
    int list ->
    int list ->
    int list ->
    bool ->
    bool ->
    t

  val avg_pool2d_forward :
    t ->
    int list ->
    int list ->
    int list ->
    bool ->
    bool ->
    t

  val avg_pool2d_forward_out :
    t ->
    t ->
    int list ->
    int list ->
    int list ->
    bool ->
    bool ->
    t

  val avg_pool2d_out :
    t ->
    t ->
    int list ->
    int list ->
    int list ->
    bool ->
    bool ->
    t

  val avg_pool3d :
    t ->
    int list ->
    int list ->
    int list ->
    bool ->
    bool ->
    t

  val avg_pool3d_backward :
    t ->
    t ->
    int list ->
    int list ->
    int list ->
    bool ->
    bool ->
    t

  val avg_pool3d_backward_out :
    t ->
    t ->
    t ->
    int list ->
    int list ->
    int list ->
    bool ->
    bool ->
    t

  val avg_pool3d_forward :
    t ->
    int list ->
    int list ->
    int list ->
    bool ->
    bool ->
    t

  val avg_pool3d_forward_out :
    t ->
    t ->
    int list ->
    int list ->
    int list ->
    bool ->
    bool ->
    t

  val avg_pool3d_out :
    t ->
    t ->
    int list ->
    int list ->
    int list ->
    bool ->
    bool ->
    t

  val baddbmm :
    t ->
    t ->
    t ->
    t

  val baddbmm_ :
    t ->
    t ->
    t ->
    t

  val baddbmm_out :
    t ->
    t ->
    t ->
    t ->
    t

  val bartlett_window1 :
    int ->
    Kind.t * Device.t ->
    t

  val bartlett_window2 :
    int ->
    bool ->
    Kind.t * Device.t ->
    t

  val batch_norm :
    t ->
    t option ->
    t option ->
    t option ->
    t option ->
    bool ->
    float ->
    float ->
    bool ->
    t

  val bernoulli1 :
    t ->
    t

  val bernoulli2 :
    t ->
    float ->
    t

  val bernoulli_ :
    t ->
    t ->
    t

  val bernoulli_1 :
    t ->
    float ->
    t

  val bernoulli_out :
    t ->
    t ->
    t

  val bilinear :
    t ->
    t ->
    t ->
    t option ->
    t

  val binary_cross_entropy :
    t ->
    t ->
    t ->
    int ->
    t

  val binary_cross_entropy_backward :
    t ->
    t ->
    t ->
    t option ->
    int ->
    t

  val binary_cross_entropy_backward_out :
    t ->
    t ->
    t ->
    t ->
    t option ->
    int ->
    t

  val binary_cross_entropy_forward :
    t ->
    t ->
    t option ->
    int ->
    t

  val binary_cross_entropy_forward_out :
    t ->
    t ->
    t ->
    t option ->
    int ->
    t

  val binary_cross_entropy_out :
    t ->
    t ->
    t ->
    t ->
    int ->
    t

  val blackman_window1 :
    int ->
    Kind.t * Device.t ->
    t

  val blackman_window2 :
    int ->
    bool ->
    Kind.t * Device.t ->
    t

  val bmm :
    t ->
    t ->
    t

  val bmm_out :
    t ->
    t ->
    t ->
    t

  val cat :
    t list ->
    int ->
    t

  val cat_out :
    t ->
    t list ->
    int ->
    t

  val cauchy_ :
    t ->
    float ->
    float ->
    t

  val ceil :
    t ->
    t

  val ceil_ :
    t ->
    t

  val ceil_out :
    t ->
    t ->
    t

  val celu :
    t ->
    t

  val celu_ :
    t ->
    t

  val clamp :
    t ->
    scalar ->
    scalar ->
    t

  val clamp_ :
    t ->
    scalar ->
    scalar ->
    t

  val clamp_max :
    t ->
    scalar ->
    t

  val clamp_max_ :
    t ->
    scalar ->
    t

  val clamp_max_out :
    t ->
    t ->
    scalar ->
    t

  val clamp_min :
    t ->
    scalar ->
    t

  val clamp_min_ :
    t ->
    scalar ->
    t

  val clamp_min_out :
    t ->
    t ->
    scalar ->
    t

  val clamp_out :
    t ->
    t ->
    scalar ->
    scalar ->
    t

  val clone :
    t ->
    t

  val coalesce :
    t ->
    t

  val contiguous :
    t ->
    t

  val conv1d :
    t ->
    t ->
    t ->
    int list ->
    int list ->
    int list ->
    int ->
    t

  val conv2d :
    t ->
    t ->
    t ->
    int list ->
    int list ->
    int list ->
    int ->
    t

  val conv3d :
    t ->
    t ->
    t ->
    int list ->
    int list ->
    int list ->
    int ->
    t

  val conv_tbc :
    t ->
    t ->
    t ->
    int ->
    t

  val conv_transpose1d :
    t ->
    t ->
    t ->
    int list ->
    int list ->
    int list ->
    int ->
    int list ->
    t

  val conv_transpose2d :
    t ->
    t ->
    t ->
    int list ->
    int list ->
    int list ->
    int ->
    int list ->
    t

  val conv_transpose3d :
    t ->
    t ->
    t ->
    int list ->
    int list ->
    int list ->
    int ->
    int list ->
    t

  val convolution :
    t ->
    t ->
    t option ->
    int list ->
    int list ->
    int list ->
    bool ->
    int list ->
    int ->
    t

  val copy_sparse_to_sparse_ :
    t ->
    t ->
    bool ->
    t

  val cos :
    t ->
    t

  val cos_ :
    t ->
    t

  val cos_out :
    t ->
    t ->
    t

  val cosh :
    t ->
    t

  val cosh_ :
    t ->
    t

  val cosh_out :
    t ->
    t ->
    t

  val cosine_embedding_loss :
    t ->
    t ->
    t ->
    float ->
    int ->
    t

  val cross :
    t ->
    t ->
    int ->
    t

  val cross_out :
    t ->
    t ->
    t ->
    int ->
    t

  val ctc_loss1 :
    t ->
    t ->
    int list ->
    int list ->
    int ->
    int ->
    t

  val ctc_loss2 :
    t ->
    t ->
    t ->
    t ->
    int ->
    int ->
    t

  val cudnn_affine_grid_generator :
    t ->
    int ->
    int ->
    int ->
    int ->
    t

  val cudnn_affine_grid_generator_backward :
    t ->
    int ->
    int ->
    int ->
    int ->
    t

  val cudnn_convolution :
    t ->
    t ->
    t option ->
    int list ->
    int list ->
    int list ->
    int ->
    bool ->
    bool ->
    t

  val cudnn_convolution_backward_bias :
    t ->
    t

  val cudnn_convolution_backward_input :
    int list ->
    t ->
    t ->
    int list ->
    int list ->
    int list ->
    int ->
    bool ->
    bool ->
    t

  val cudnn_convolution_backward_weight :
    int list ->
    t ->
    t ->
    int list ->
    int list ->
    int list ->
    int ->
    bool ->
    bool ->
    t

  val cudnn_convolution_transpose :
    t ->
    t ->
    t option ->
    int list ->
    int list ->
    int list ->
    int list ->
    int ->
    bool ->
    bool ->
    t

  val cudnn_convolution_transpose_backward_bias :
    t ->
    t

  val cudnn_convolution_transpose_backward_input :
    t ->
    t ->
    int list ->
    int list ->
    int list ->
    int ->
    bool ->
    bool ->
    t

  val cudnn_convolution_transpose_backward_weight :
    int list ->
    t ->
    t ->
    int list ->
    int list ->
    int list ->
    int ->
    bool ->
    bool ->
    t

  val cudnn_grid_sampler :
    t ->
    t ->
    t

  val cumprod1 :
    t ->
    int ->
    Kind.t ->
    t

  val cumprod2 :
    t ->
    int ->
    t

  val cumprod_out1 :
    t ->
    t ->
    int ->
    Kind.t ->
    t

  val cumprod_out2 :
    t ->
    t ->
    int ->
    t

  val cumsum1 :
    t ->
    int ->
    Kind.t ->
    t

  val cumsum2 :
    t ->
    int ->
    t

  val cumsum_out1 :
    t ->
    t ->
    int ->
    Kind.t ->
    t

  val cumsum_out2 :
    t ->
    t ->
    int ->
    t

  val det :
    t ->
    t

  val detach :
    t ->
    t

  val detach_ :
    t ->
    t

  val diag :
    t ->
    int ->
    t

  val diag_out :
    t ->
    t ->
    int ->
    t

  val diagflat :
    t ->
    int ->
    t

  val diagonal :
    t ->
    int ->
    int ->
    int ->
    t

  val digamma :
    t ->
    t

  val digamma_ :
    t ->
    t

  val digamma_out :
    t ->
    t ->
    t

  val div :
    t ->
    t ->
    t

  val div1 :
    t ->
    scalar ->
    t

  val div_ :
    t ->
    t ->
    t

  val div_1 :
    t ->
    scalar ->
    t

  val div_out :
    t ->
    t ->
    t ->
    t

  val dot :
    t ->
    t ->
    t

  val dot_out :
    t ->
    t ->
    t ->
    t

  val dropout :
    t ->
    float ->
    bool ->
    t

  val dropout_ :
    t ->
    float ->
    bool ->
    t

  val elu :
    t ->
    t

  val elu_ :
    t ->
    t

  val elu_out :
    t ->
    t ->
    t

  val embedding :
    t ->
    t ->
    int ->
    bool ->
    bool ->
    t

  val embedding_backward :
    t ->
    t ->
    int ->
    int ->
    bool ->
    bool ->
    t

  val embedding_dense_backward :
    t ->
    t ->
    int ->
    int ->
    bool ->
    t

  val embedding_renorm_ :
    t ->
    t ->
    float ->
    float ->
    t

  val embedding_sparse_backward :
    t ->
    t ->
    int ->
    int ->
    bool ->
    t

  val empty :
    int list ->
    Kind.t * Device.t ->
    t

  val empty_like1 :
    t ->
    t

  val empty_like2 :
    t ->
    Kind.t * Device.t ->
    t

  val empty_out :
    t ->
    int list ->
    t

  val empty_strided :
    int list ->
    int list ->
    Kind.t * Device.t ->
    t

  val eq :
    t ->
    t ->
    t

  val eq_ :
    t ->
    t ->
    t

  val eq_out :
    t ->
    t ->
    t ->
    t

  val erf :
    t ->
    t

  val erf_ :
    t ->
    t

  val erf_out :
    t ->
    t ->
    t

  val erfc :
    t ->
    t

  val erfc_ :
    t ->
    t

  val erfc_out :
    t ->
    t ->
    t

  val erfinv :
    t ->
    t

  val erfinv_ :
    t ->
    t

  val erfinv_out :
    t ->
    t ->
    t

  val exp :
    t ->
    t

  val exp_ :
    t ->
    t

  val exp_out :
    t ->
    t ->
    t

  val expand :
    t ->
    int list ->
    bool ->
    t

  val expand_as :
    t ->
    t ->
    t

  val expm1 :
    t ->
    t

  val expm1_ :
    t ->
    t

  val expm1_out :
    t ->
    t ->
    t

  val exponential_ :
    t ->
    float ->
    t

  val eye1 :
    int ->
    Kind.t * Device.t ->
    t

  val eye2 :
    int ->
    int ->
    Kind.t * Device.t ->
    t

  val eye_out1 :
    t ->
    int ->
    t

  val eye_out2 :
    t ->
    int ->
    int ->
    t

  val feature_alpha_dropout :
    t ->
    float ->
    bool ->
    t

  val feature_alpha_dropout_ :
    t ->
    float ->
    bool ->
    t

  val feature_dropout :
    t ->
    float ->
    bool ->
    t

  val feature_dropout_ :
    t ->
    float ->
    bool ->
    t

  val fft :
    t ->
    int ->
    bool ->
    t

  val fill_ :
    t ->
    t ->
    t

  val fill_1 :
    t ->
    scalar ->
    t

  val flatten :
    t ->
    int ->
    int ->
    t

  val flip :
    t ->
    int list ->
    t

  val floor :
    t ->
    t

  val floor_ :
    t ->
    t

  val floor_out :
    t ->
    t ->
    t

  val fmod :
    t ->
    t ->
    t

  val fmod_ :
    t ->
    t ->
    t

  val fmod_out :
    t ->
    t ->
    t ->
    t

  val frac :
    t ->
    t

  val frac_ :
    t ->
    t

  val frac_out :
    t ->
    t ->
    t

  val fractional_max_pool2d_backward :
    t ->
    t ->
    int list ->
    int list ->
    t ->
    t

  val fractional_max_pool2d_backward_out :
    t ->
    t ->
    t ->
    int list ->
    int list ->
    t ->
    t

  val frobenius_norm1 :
    t ->
    t

  val frobenius_norm2 :
    t ->
    int list ->
    bool ->
    t

  val frobenius_norm_out :
    t ->
    t ->
    int list ->
    bool ->
    t

  val full :
    int list ->
    scalar ->
    Kind.t * Device.t ->
    t

  val full_like1 :
    t ->
    scalar ->
    t

  val full_like2 :
    t ->
    scalar ->
    Kind.t * Device.t ->
    t

  val full_out :
    t ->
    int list ->
    scalar ->
    t

  val gather :
    t ->
    int ->
    t ->
    t

  val gather_out :
    t ->
    t ->
    int ->
    t ->
    t

  val ge :
    t ->
    t ->
    t

  val ge_ :
    t ->
    t ->
    t

  val ge_out :
    t ->
    t ->
    t ->
    t

  val geometric_ :
    t ->
    float ->
    t

  val ger :
    t ->
    t ->
    t

  val ger_out :
    t ->
    t ->
    t ->
    t

  val glu :
    t ->
    int ->
    t

  val glu_backward :
    t ->
    t ->
    int ->
    t

  val glu_backward_out :
    t ->
    t ->
    t ->
    int ->
    t

  val glu_forward :
    t ->
    int ->
    t

  val glu_forward_out :
    t ->
    t ->
    int ->
    t

  val glu_out :
    t ->
    t ->
    int ->
    t

  val grad :
    t ->
    t

  val grid_sampler :
    t ->
    t ->
    int ->
    int ->
    t

  val grid_sampler_2d :
    t ->
    t ->
    int ->
    int ->
    t

  val grid_sampler_3d :
    t ->
    t ->
    int ->
    int ->
    t

  val gru_cell :
    t ->
    t ->
    t ->
    t ->
    t option ->
    t option ->
    t

  val gt :
    t ->
    t ->
    t

  val gt_ :
    t ->
    t ->
    t

  val gt_out :
    t ->
    t ->
    t ->
    t

  val hamming_window1 :
    int ->
    Kind.t * Device.t ->
    t

  val hamming_window2 :
    int ->
    bool ->
    Kind.t * Device.t ->
    t

  val hamming_window3 :
    int ->
    bool ->
    float ->
    Kind.t * Device.t ->
    t

  val hamming_window4 :
    int ->
    bool ->
    float ->
    float ->
    Kind.t * Device.t ->
    t

  val hann_window1 :
    int ->
    Kind.t * Device.t ->
    t

  val hann_window2 :
    int ->
    bool ->
    Kind.t * Device.t ->
    t

  val hardshrink :
    t ->
    t

  val hardshrink_backward :
    t ->
    t ->
    scalar ->
    t

  val hardtanh :
    t ->
    t

  val hardtanh_ :
    t ->
    t

  val hardtanh_out :
    t ->
    t ->
    t

  val hinge_embedding_loss :
    t ->
    t ->
    float ->
    int ->
    t

  val histc :
    t ->
    int ->
    t

  val histc_out :
    t ->
    t ->
    int ->
    t

  val hspmm :
    t ->
    t ->
    t

  val hspmm_out :
    t ->
    t ->
    t ->
    t

  val ifft :
    t ->
    int ->
    bool ->
    t

  val index :
    t ->
    t list ->
    t

  val index_add_ :
    t ->
    int ->
    t ->
    t ->
    t

  val index_copy_ :
    t ->
    int ->
    t ->
    t ->
    t

  val index_fill_ :
    t ->
    int ->
    t ->
    t ->
    t

  val index_put :
    t ->
    t list ->
    t ->
    t

  val index_put_ :
    t ->
    t list ->
    t ->
    t

  val index_select :
    t ->
    int ->
    t ->
    t

  val index_select_out :
    t ->
    t ->
    int ->
    t ->
    t

  val instance_norm :
    t ->
    t option ->
    t option ->
    t option ->
    t option ->
    bool ->
    float ->
    float ->
    bool ->
    t

  val inverse :
    t ->
    t

  val inverse_out :
    t ->
    t ->
    t

  val irfft :
    t ->
    int ->
    bool ->
    bool ->
    int list ->
    t

  val isclose :
    t ->
    t ->
    float ->
    float ->
    bool ->
    t

  val kl_div :
    t ->
    t ->
    int ->
    t

  val kl_div_backward :
    t ->
    t ->
    t ->
    int ->
    t

  val l1_loss :
    t ->
    t ->
    int ->
    t

  val l1_loss_backward :
    t ->
    t ->
    t ->
    int ->
    t

  val l1_loss_backward_out :
    t ->
    t ->
    t ->
    t ->
    int ->
    t

  val l1_loss_forward :
    t ->
    t ->
    int ->
    t

  val l1_loss_forward_out :
    t ->
    t ->
    t ->
    int ->
    t

  val l1_loss_out :
    t ->
    t ->
    t ->
    int ->
    t

  val le :
    t ->
    t ->
    t

  val le_ :
    t ->
    t ->
    t

  val le_out :
    t ->
    t ->
    t ->
    t

  val leaky_relu :
    t ->
    t

  val leaky_relu_ :
    t ->
    t

  val leaky_relu_out :
    t ->
    t ->
    t

  val lgamma :
    t ->
    t

  val lgamma_ :
    t ->
    t

  val lgamma_out :
    t ->
    t ->
    t

  val linear :
    t ->
    t ->
    t ->
    t

  val linspace1 :
    scalar ->
    scalar ->
    Kind.t * Device.t ->
    t

  val linspace2 :
    scalar ->
    scalar ->
    int ->
    Kind.t * Device.t ->
    t

  val linspace_out1 :
    t ->
    scalar ->
    scalar ->
    t

  val linspace_out2 :
    t ->
    scalar ->
    scalar ->
    int ->
    t

  val log :
    t ->
    t

  val log10 :
    t ->
    t

  val log10_ :
    t ->
    t

  val log10_out :
    t ->
    t ->
    t

  val log1p :
    t ->
    t

  val log1p_ :
    t ->
    t

  val log1p_out :
    t ->
    t ->
    t

  val log2 :
    t ->
    t

  val log2_ :
    t ->
    t

  val log2_out :
    t ->
    t ->
    t

  val log_ :
    t ->
    t

  val log_normal_ :
    t ->
    float ->
    float ->
    t

  val log_out :
    t ->
    t ->
    t

  val log_sigmoid :
    t ->
    t

  val log_sigmoid_backward :
    t ->
    t ->
    t ->
    t

  val log_sigmoid_backward_out :
    t ->
    t ->
    t ->
    t ->
    t

  val log_sigmoid_out :
    t ->
    t ->
    t

  val log_softmax :
    t ->
    int ->
    t

  val logdet :
    t ->
    t

  val logspace1 :
    scalar ->
    scalar ->
    Kind.t * Device.t ->
    t

  val logspace2 :
    scalar ->
    scalar ->
    int ->
    Kind.t * Device.t ->
    t

  val logspace_out1 :
    t ->
    scalar ->
    scalar ->
    t

  val logspace_out2 :
    t ->
    scalar ->
    scalar ->
    int ->
    t

  val logsumexp :
    t ->
    int ->
    bool ->
    t

  val logsumexp_out :
    t ->
    t ->
    int ->
    bool ->
    t

  val lt :
    t ->
    t ->
    t

  val lt_ :
    t ->
    t ->
    t

  val lt_out :
    t ->
    t ->
    t ->
    t

  val margin_ranking_loss :
    t ->
    t ->
    t ->
    float ->
    int ->
    t

  val masked_fill_ :
    t ->
    t ->
    t ->
    t

  val masked_scatter_ :
    t ->
    t ->
    t ->
    t

  val masked_select :
    t ->
    t ->
    t

  val masked_select_out :
    t ->
    t ->
    t ->
    t

  val matmul :
    t ->
    t ->
    t

  val matmul_out :
    t ->
    t ->
    t ->
    t

  val matrix_power :
    t ->
    int ->
    t

  val matrix_rank1 :
    t ->
    float ->
    bool ->
    t

  val matrix_rank2 :
    t ->
    bool ->
    t

  val max :
    t ->
    t ->
    t

  val max_out :
    t ->
    t ->
    t ->
    t

  val max_pool1d :
    t ->
    int list ->
    int list ->
    int list ->
    int list ->
    bool ->
    t

  val max_pool2d :
    t ->
    int list ->
    int list ->
    int list ->
    int list ->
    bool ->
    t

  val max_pool2d_with_indices_backward :
    t ->
    t ->
    int list ->
    int list ->
    int list ->
    int list ->
    bool ->
    t ->
    t

  val max_pool2d_with_indices_backward_out :
    t ->
    t ->
    t ->
    int list ->
    int list ->
    int list ->
    int list ->
    bool ->
    t ->
    t

  val max_pool3d :
    t ->
    int list ->
    int list ->
    int list ->
    int list ->
    bool ->
    t

  val max_pool3d_with_indices_backward :
    t ->
    t ->
    int list ->
    int list ->
    int list ->
    int list ->
    bool ->
    t ->
    t

  val max_pool3d_with_indices_backward_out :
    t ->
    t ->
    t ->
    int list ->
    int list ->
    int list ->
    int list ->
    bool ->
    t ->
    t

  val max_unpool2d :
    t ->
    t ->
    int list ->
    t

  val max_unpool2d_backward :
    t ->
    t ->
    t ->
    int list ->
    t

  val max_unpool2d_backward_out :
    t ->
    t ->
    t ->
    t ->
    int list ->
    t

  val max_unpool2d_forward :
    t ->
    t ->
    int list ->
    t

  val max_unpool2d_forward_out :
    t ->
    t ->
    t ->
    int list ->
    t

  val max_unpool2d_out :
    t ->
    t ->
    t ->
    int list ->
    t

  val max_unpool3d :
    t ->
    t ->
    int list ->
    int list ->
    int list ->
    t

  val max_unpool3d_backward :
    t ->
    t ->
    t ->
    int list ->
    int list ->
    int list ->
    t

  val max_unpool3d_backward_out :
    t ->
    t ->
    t ->
    t ->
    int list ->
    int list ->
    int list ->
    t

  val max_unpool3d_forward :
    t ->
    t ->
    int list ->
    int list ->
    int list ->
    t

  val max_unpool3d_forward_out :
    t ->
    t ->
    t ->
    int list ->
    int list ->
    int list ->
    t

  val max_unpool3d_out :
    t ->
    t ->
    t ->
    int list ->
    int list ->
    int list ->
    t

  val max_values :
    t ->
    int ->
    bool ->
    t

  val mean1 :
    t ->
    Kind.t ->
    t

  val mean2 :
    t ->
    t

  val mean3 :
    t ->
    int ->
    bool ->
    Kind.t ->
    t

  val mean4 :
    t ->
    int ->
    bool ->
    t

  val mean5 :
    t ->
    int ->
    Kind.t ->
    t

  val mean_out1 :
    t ->
    t ->
    int ->
    bool ->
    Kind.t ->
    t

  val mean_out2 :
    t ->
    t ->
    int ->
    bool ->
    t

  val mean_out3 :
    t ->
    t ->
    int ->
    Kind.t ->
    t

  val min :
    t ->
    t ->
    t

  val min_out :
    t ->
    t ->
    t ->
    t

  val min_values :
    t ->
    int ->
    bool ->
    t

  val miopen_convolution :
    t ->
    t ->
    t option ->
    int list ->
    int list ->
    int list ->
    int ->
    bool ->
    bool ->
    t

  val miopen_convolution_backward_bias :
    t ->
    t

  val miopen_convolution_backward_input :
    int list ->
    t ->
    t ->
    int list ->
    int list ->
    int list ->
    int ->
    bool ->
    bool ->
    t

  val miopen_convolution_backward_weight :
    int list ->
    t ->
    t ->
    int list ->
    int list ->
    int list ->
    int ->
    bool ->
    bool ->
    t

  val miopen_convolution_transpose :
    t ->
    t ->
    t option ->
    int list ->
    int list ->
    int list ->
    int list ->
    int ->
    bool ->
    bool ->
    t

  val miopen_convolution_transpose_backward_input :
    t ->
    t ->
    int list ->
    int list ->
    int list ->
    int ->
    bool ->
    bool ->
    t

  val miopen_convolution_transpose_backward_weight :
    int list ->
    t ->
    t ->
    int list ->
    int list ->
    int list ->
    int ->
    bool ->
    bool ->
    t

  val mkldnn_convolution :
    t ->
    t ->
    t option ->
    int list ->
    int list ->
    int list ->
    int ->
    t

  val mkldnn_convolution_backward_input :
    int list ->
    t ->
    t ->
    int list ->
    int list ->
    int list ->
    int ->
    bool ->
    t

  val mm :
    t ->
    t ->
    t

  val mm_out :
    t ->
    t ->
    t ->
    t

  val mse_loss :
    t ->
    t ->
    int ->
    t

  val mse_loss_backward :
    t ->
    t ->
    t ->
    int ->
    t

  val mse_loss_backward_out :
    t ->
    t ->
    t ->
    t ->
    int ->
    t

  val mse_loss_forward :
    t ->
    t ->
    int ->
    t

  val mse_loss_forward_out :
    t ->
    t ->
    t ->
    int ->
    t

  val mse_loss_out :
    t ->
    t ->
    t ->
    int ->
    t

  val mul :
    t ->
    t ->
    t

  val mul1 :
    t ->
    scalar ->
    t

  val mul_ :
    t ->
    t ->
    t

  val mul_1 :
    t ->
    scalar ->
    t

  val mul_out :
    t ->
    t ->
    t ->
    t

  val multilabel_margin_loss :
    t ->
    t ->
    int ->
    t

  val multilabel_margin_loss_backward :
    t ->
    t ->
    t ->
    int ->
    t ->
    t

  val multilabel_margin_loss_backward_out :
    t ->
    t ->
    t ->
    t ->
    int ->
    t ->
    t

  val multilabel_margin_loss_out :
    t ->
    t ->
    t ->
    int ->
    t

  val mv :
    t ->
    t ->
    t

  val mv_out :
    t ->
    t ->
    t ->
    t

  val mvlgamma :
    t ->
    int ->
    t

  val mvlgamma_ :
    t ->
    int ->
    t

  val narrow :
    t ->
    int ->
    int ->
    int ->
    t

  val narrow_copy :
    t ->
    int ->
    int ->
    int ->
    t

  val native_clone :
    t ->
    t

  val native_norm :
    t ->
    t

  val native_pow :
    t ->
    scalar ->
    t

  val native_pow_out :
    t ->
    t ->
    scalar ->
    t

  val native_resize_as_ :
    t ->
    t ->
    t

  val native_zero_ :
    t ->
    t

  val ne :
    t ->
    t ->
    t

  val ne_ :
    t ->
    t ->
    t

  val ne_out :
    t ->
    t ->
    t ->
    t

  val neg :
    t ->
    t

  val neg_ :
    t ->
    t

  val neg_out :
    t ->
    t ->
    t

  val nll_loss :
    t ->
    t ->
    t ->
    int ->
    int ->
    t

  val nll_loss2d :
    t ->
    t ->
    t ->
    int ->
    int ->
    t

  val nll_loss2d_backward :
    t ->
    t ->
    t ->
    t option ->
    int ->
    int ->
    t ->
    t

  val nll_loss2d_backward_out :
    t ->
    t ->
    t ->
    t ->
    t option ->
    int ->
    int ->
    t ->
    t

  val nll_loss2d_out :
    t ->
    t ->
    t ->
    t ->
    int ->
    int ->
    t

  val nll_loss_backward :
    t ->
    t ->
    t ->
    t option ->
    int ->
    int ->
    t ->
    t

  val nll_loss_backward_out :
    t ->
    t ->
    t ->
    t ->
    t option ->
    int ->
    int ->
    t ->
    t

  val nll_loss_out :
    t ->
    t ->
    t ->
    t ->
    int ->
    int ->
    t

  val norm1 :
    t ->
    t

  val norm2 :
    t ->
    scalar ->
    int ->
    bool ->
    t

  val norm_except_dim :
    t ->
    int ->
    int ->
    t

  val norm_out :
    t ->
    t ->
    scalar ->
    int ->
    bool ->
    t

  val normal :
    t ->
    t ->
    t

  val normal1 :
    t ->
    float ->
    t

  val normal2 :
    float ->
    t ->
    t

  val normal_ :
    t ->
    float ->
    float ->
    t

  val normal_out1 :
    t ->
    t ->
    float ->
    t

  val normal_out2 :
    t ->
    float ->
    t ->
    t

  val normal_out3 :
    t ->
    t ->
    t ->
    t

  val nuclear_norm :
    t ->
    bool ->
    t

  val nuclear_norm_out :
    t ->
    t ->
    bool ->
    t

  val ones :
    int list ->
    Kind.t * Device.t ->
    t

  val ones_like1 :
    t ->
    t

  val ones_like2 :
    t ->
    Kind.t * Device.t ->
    t

  val ones_out :
    t ->
    int list ->
    t

  val orgqr :
    t ->
    t ->
    t

  val orgqr_out :
    t ->
    t ->
    t ->
    t

  val ormqr :
    t ->
    t ->
    t ->
    bool ->
    bool ->
    t

  val ormqr_out :
    t ->
    t ->
    t ->
    t ->
    bool ->
    bool ->
    t

  val pairwise_distance :
    t ->
    t ->
    float ->
    float ->
    bool ->
    t

  val pdist :
    t ->
    float ->
    t

  val permute :
    t ->
    int list ->
    t

  val pin_memory :
    t ->
    t

  val pinverse :
    t ->
    float ->
    t

  val pixel_shuffle :
    t ->
    int ->
    t

  val poisson :
    t ->
    t

  val polygamma :
    int ->
    t ->
    t

  val polygamma_ :
    t ->
    int ->
    t

  val polygamma_out :
    t ->
    int ->
    t ->
    t

  val potrf :
    t ->
    bool ->
    t

  val potrf_out :
    t ->
    t ->
    bool ->
    t

  val potri :
    t ->
    bool ->
    t

  val potri_out :
    t ->
    t ->
    bool ->
    t

  val potrs :
    t ->
    t ->
    bool ->
    t

  val potrs_out :
    t ->
    t ->
    t ->
    bool ->
    t

  val pow :
    t ->
    t ->
    t

  val pow1 :
    t ->
    scalar ->
    t

  val pow_ :
    t ->
    t ->
    t

  val pow_out1 :
    t ->
    t ->
    t ->
    t

  val pow_out2 :
    t ->
    t ->
    scalar ->
    t

  val prelu :
    t ->
    t ->
    t

  val prod1 :
    t ->
    Kind.t ->
    t

  val prod2 :
    t ->
    t

  val prod3 :
    t ->
    int ->
    bool ->
    Kind.t ->
    t

  val prod4 :
    t ->
    int ->
    bool ->
    t

  val prod5 :
    t ->
    int ->
    Kind.t ->
    t

  val prod_out1 :
    t ->
    t ->
    int ->
    bool ->
    Kind.t ->
    t

  val prod_out2 :
    t ->
    t ->
    int ->
    bool ->
    t

  val prod_out3 :
    t ->
    t ->
    int ->
    Kind.t ->
    t

  val put_ :
    t ->
    t ->
    t ->
    bool ->
    t

  val rand :
    int list ->
    Kind.t * Device.t ->
    t

  val rand_like1 :
    t ->
    t

  val rand_like2 :
    t ->
    Kind.t * Device.t ->
    t

  val rand_out :
    t ->
    int list ->
    t

  val randint1 :
    int ->
    int list ->
    Kind.t * Device.t ->
    t

  val randint2 :
    int ->
    int ->
    int list ->
    Kind.t * Device.t ->
    t

  val randint_like1 :
    t ->
    int ->
    t

  val randint_like2 :
    t ->
    int ->
    int ->
    t

  val randint_like3 :
    t ->
    int ->
    Kind.t * Device.t ->
    t

  val randint_like4 :
    t ->
    int ->
    int ->
    Kind.t * Device.t ->
    t

  val randint_out1 :
    t ->
    int ->
    int list ->
    t

  val randint_out2 :
    t ->
    int ->
    int ->
    int list ->
    t

  val randn :
    int list ->
    Kind.t * Device.t ->
    t

  val randn_like1 :
    t ->
    t

  val randn_like2 :
    t ->
    Kind.t * Device.t ->
    t

  val randn_out :
    t ->
    int list ->
    t

  val random_1 :
    t ->
    int ->
    int ->
    t

  val random_2 :
    t ->
    int ->
    t

  val random_3 :
    t ->
    t

  val randperm :
    int ->
    Kind.t * Device.t ->
    t

  val randperm_out :
    t ->
    int ->
    t

  val range1 :
    scalar ->
    scalar ->
    Kind.t * Device.t ->
    t

  val range2 :
    scalar ->
    scalar ->
    scalar ->
    Kind.t * Device.t ->
    t

  val range_out1 :
    t ->
    scalar ->
    scalar ->
    t

  val range_out2 :
    t ->
    scalar ->
    scalar ->
    scalar ->
    t

  val reciprocal :
    t ->
    t

  val reciprocal_ :
    t ->
    t

  val reciprocal_out :
    t ->
    t ->
    t

  val reflection_pad1d :
    t ->
    int list ->
    t

  val reflection_pad1d_backward :
    t ->
    t ->
    int list ->
    t

  val reflection_pad1d_backward_out :
    t ->
    t ->
    t ->
    int list ->
    t

  val reflection_pad1d_forward :
    t ->
    int list ->
    t

  val reflection_pad1d_forward_out :
    t ->
    t ->
    int list ->
    t

  val reflection_pad1d_out :
    t ->
    t ->
    int list ->
    t

  val reflection_pad2d :
    t ->
    int list ->
    t

  val reflection_pad2d_backward :
    t ->
    t ->
    int list ->
    t

  val reflection_pad2d_backward_out :
    t ->
    t ->
    t ->
    int list ->
    t

  val reflection_pad2d_forward :
    t ->
    int list ->
    t

  val reflection_pad2d_forward_out :
    t ->
    t ->
    int list ->
    t

  val reflection_pad2d_out :
    t ->
    t ->
    int list ->
    t

  val relu :
    t ->
    t

  val relu_ :
    t ->
    t

  val remainder :
    t ->
    t ->
    t

  val remainder_ :
    t ->
    t ->
    t

  val remainder_out :
    t ->
    t ->
    t ->
    t

  val repeat :
    t ->
    int list ->
    t

  val replication_pad1d :
    t ->
    int list ->
    t

  val replication_pad1d_backward :
    t ->
    t ->
    int list ->
    t

  val replication_pad1d_backward_out :
    t ->
    t ->
    t ->
    int list ->
    t

  val replication_pad1d_forward :
    t ->
    int list ->
    t

  val replication_pad1d_forward_out :
    t ->
    t ->
    int list ->
    t

  val replication_pad1d_out :
    t ->
    t ->
    int list ->
    t

  val replication_pad2d :
    t ->
    int list ->
    t

  val replication_pad2d_backward :
    t ->
    t ->
    int list ->
    t

  val replication_pad2d_backward_out :
    t ->
    t ->
    t ->
    int list ->
    t

  val replication_pad2d_forward :
    t ->
    int list ->
    t

  val replication_pad2d_forward_out :
    t ->
    t ->
    int list ->
    t

  val replication_pad2d_out :
    t ->
    t ->
    int list ->
    t

  val replication_pad3d :
    t ->
    int list ->
    t

  val replication_pad3d_backward :
    t ->
    t ->
    int list ->
    t

  val replication_pad3d_backward_out :
    t ->
    t ->
    t ->
    int list ->
    t

  val replication_pad3d_forward :
    t ->
    int list ->
    t

  val replication_pad3d_forward_out :
    t ->
    t ->
    int list ->
    t

  val replication_pad3d_out :
    t ->
    t ->
    int list ->
    t

  val reshape :
    t ->
    int list ->
    t

  val reshape_as :
    t ->
    t ->
    t

  val resize_ :
    t ->
    int list ->
    t

  val resize_as_ :
    t ->
    t ->
    t

  val rfft :
    t ->
    int ->
    bool ->
    bool ->
    t

  val rnn_relu_cell :
    t ->
    t ->
    t ->
    t ->
    t option ->
    t option ->
    t

  val rnn_tanh_cell :
    t ->
    t ->
    t ->
    t ->
    t option ->
    t option ->
    t

  val roipooling2d_backward :
    t ->
    t ->
    int ->
    int ->
    float ->
    t ->
    t ->
    t

  val round :
    t ->
    t

  val round_ :
    t ->
    t

  val round_out :
    t ->
    t ->
    t

  val rrelu :
    t ->
    bool ->
    t

  val rrelu_ :
    t ->
    bool ->
    t

  val rrelu_with_noise :
    t ->
    t ->
    bool ->
    t

  val rrelu_with_noise_ :
    t ->
    t ->
    bool ->
    t

  val rrelu_with_noise_out :
    t ->
    t ->
    t ->
    bool ->
    t

  val rsqrt :
    t ->
    t

  val rsqrt_ :
    t ->
    t

  val rsqrt_out :
    t ->
    t ->
    t

  val s_native_addmm :
    t ->
    t ->
    t ->
    t

  val s_native_addmm_ :
    t ->
    t ->
    t ->
    t

  val s_native_addmm_out :
    t ->
    t ->
    t ->
    t ->
    t

  val scatter_ :
    t ->
    int ->
    t ->
    t ->
    t

  val scatter_add_ :
    t ->
    int ->
    t ->
    t ->
    t

  val select :
    t ->
    int ->
    int ->
    t

  val selu :
    t ->
    t

  val selu_ :
    t ->
    t

  val set_ :
    t ->
    t ->
    t

  val set_1 :
    t ->
    t

  val set_requires_grad :
    t ->
    bool ->
    t

  val sigmoid :
    t ->
    t

  val sigmoid_ :
    t ->
    t

  val sigmoid_out :
    t ->
    t ->
    t

  val sign :
    t ->
    t

  val sign_ :
    t ->
    t

  val sign_out :
    t ->
    t ->
    t

  val sin :
    t ->
    t

  val sin_ :
    t ->
    t

  val sin_out :
    t ->
    t ->
    t

  val sinh :
    t ->
    t

  val sinh_ :
    t ->
    t

  val sinh_out :
    t ->
    t ->
    t

  val slice :
    t ->
    int ->
    int ->
    int ->
    int ->
    t

  val smm :
    t ->
    t ->
    t

  val smooth_l1_loss :
    t ->
    t ->
    int ->
    t

  val smooth_l1_loss_backward :
    t ->
    t ->
    t ->
    int ->
    t

  val smooth_l1_loss_backward_out :
    t ->
    t ->
    t ->
    t ->
    int ->
    t

  val smooth_l1_loss_forward :
    t ->
    t ->
    int ->
    t

  val smooth_l1_loss_forward_out :
    t ->
    t ->
    t ->
    int ->
    t

  val smooth_l1_loss_out :
    t ->
    t ->
    t ->
    int ->
    t

  val soft_margin_loss :
    t ->
    t ->
    int ->
    t

  val soft_margin_loss_backward :
    t ->
    t ->
    t ->
    int ->
    t

  val soft_margin_loss_backward_out :
    t ->
    t ->
    t ->
    t ->
    int ->
    t

  val soft_margin_loss_forward :
    t ->
    t ->
    int ->
    t

  val soft_margin_loss_forward_out :
    t ->
    t ->
    t ->
    int ->
    t

  val soft_margin_loss_out :
    t ->
    t ->
    t ->
    int ->
    t

  val softmax :
    t ->
    int ->
    t

  val softplus :
    t ->
    t

  val softplus_out :
    t ->
    t ->
    t

  val softshrink :
    t ->
    t

  val softshrink_out :
    t ->
    t ->
    t

  val sparse_resize_ :
    t ->
    int list ->
    int ->
    int ->
    t

  val sparse_resize_and_clear_ :
    t ->
    int list ->
    int ->
    int ->
    t

  val sqrt :
    t ->
    t

  val sqrt_ :
    t ->
    t

  val sqrt_out :
    t ->
    t ->
    t

  val squeeze1 :
    t ->
    t

  val squeeze2 :
    t ->
    int ->
    t

  val squeeze_1 :
    t ->
    t

  val squeeze_2 :
    t ->
    int ->
    t

  val sspaddmm :
    t ->
    t ->
    t ->
    t

  val sspaddmm_out :
    t ->
    t ->
    t ->
    t ->
    t

  val stack :
    t list ->
    int ->
    t

  val stack_out :
    t ->
    t list ->
    int ->
    t

  val std1 :
    t ->
    bool ->
    t

  val std2 :
    t ->
    int ->
    bool ->
    bool ->
    t

  val std_out :
    t ->
    t ->
    int ->
    bool ->
    bool ->
    t

  val sub :
    t ->
    t ->
    t

  val sub1 :
    t ->
    scalar ->
    t

  val sub_ :
    t ->
    t ->
    t

  val sub_1 :
    t ->
    scalar ->
    t

  val sub_out :
    t ->
    t ->
    t ->
    t

  val sum1 :
    t ->
    Kind.t ->
    t

  val sum2 :
    t ->
    t

  val sum3 :
    t ->
    int list ->
    bool ->
    Kind.t ->
    t

  val sum4 :
    t ->
    int list ->
    bool ->
    t

  val sum5 :
    t ->
    int list ->
    Kind.t ->
    t

  val sum_out1 :
    t ->
    t ->
    int list ->
    bool ->
    Kind.t ->
    t

  val sum_out2 :
    t ->
    t ->
    int list ->
    bool ->
    t

  val sum_out3 :
    t ->
    t ->
    int list ->
    Kind.t ->
    t

  val t_ :
    t ->
    t

  val take :
    t ->
    t ->
    t

  val take_out :
    t ->
    t ->
    t ->
    t

  val tan :
    t ->
    t

  val tan_ :
    t ->
    t

  val tan_out :
    t ->
    t ->
    t

  val tanh :
    t ->
    t

  val tanh_ :
    t ->
    t

  val tanh_out :
    t ->
    t ->
    t

  val tensordot :
    t ->
    t ->
    int list ->
    int list ->
    t

  val th_addmm :
    t ->
    t ->
    t ->
    t

  val th_addmm_ :
    t ->
    t ->
    t ->
    t

  val th_addmm_out :
    t ->
    t ->
    t ->
    t ->
    t

  val th_clone :
    t ->
    t

  val th_resize_as_ :
    t ->
    t ->
    t

  val th_zero_ :
    t ->
    t

  val thnn_batch_norm :
    t ->
    t ->
    t ->
    t ->
    t ->
    bool ->
    float ->
    float ->
    t

  val thnn_batch_norm_out :
    t ->
    t ->
    t ->
    t ->
    t ->
    t ->
    bool ->
    float ->
    float ->
    t

  val thnn_conv2d :
    t ->
    t ->
    int list ->
    t ->
    int list ->
    int list ->
    t

  val thnn_conv2d_out :
    t ->
    t ->
    t ->
    int list ->
    t ->
    int list ->
    int list ->
    t

  val thnn_conv3d :
    t ->
    t ->
    int list ->
    t ->
    int list ->
    int list ->
    t

  val thnn_conv3d_out :
    t ->
    t ->
    t ->
    int list ->
    t ->
    int list ->
    int list ->
    t

  val thnn_conv_depthwise2d :
    t ->
    t ->
    int list ->
    t ->
    int list ->
    int list ->
    int list ->
    t

  val thnn_conv_depthwise2d_forward :
    t ->
    t ->
    int list ->
    t option ->
    int list ->
    int list ->
    int list ->
    t

  val thnn_conv_depthwise2d_forward_out :
    t ->
    t ->
    t ->
    int list ->
    t option ->
    int list ->
    int list ->
    int list ->
    t

  val thnn_conv_depthwise2d_out :
    t ->
    t ->
    t ->
    int list ->
    t ->
    int list ->
    int list ->
    int list ->
    t

  val thnn_conv_dilated2d :
    t ->
    t ->
    int list ->
    t ->
    int list ->
    int list ->
    int list ->
    t

  val thnn_conv_dilated2d_out :
    t ->
    t ->
    t ->
    int list ->
    t ->
    int list ->
    int list ->
    int list ->
    t

  val thnn_conv_dilated3d :
    t ->
    t ->
    int list ->
    t ->
    int list ->
    int list ->
    int list ->
    t

  val thnn_conv_dilated3d_out :
    t ->
    t ->
    t ->
    int list ->
    t ->
    int list ->
    int list ->
    int list ->
    t

  val thnn_conv_transpose2d :
    t ->
    t ->
    int list ->
    t ->
    int list ->
    int list ->
    int list ->
    int list ->
    t

  val thnn_conv_transpose2d_out :
    t ->
    t ->
    t ->
    int list ->
    t ->
    int list ->
    int list ->
    int list ->
    int list ->
    t

  val thnn_conv_transpose3d :
    t ->
    t ->
    int list ->
    t ->
    int list ->
    int list ->
    int list ->
    int list ->
    t

  val thnn_conv_transpose3d_out :
    t ->
    t ->
    t ->
    int list ->
    t ->
    int list ->
    int list ->
    int list ->
    int list ->
    t

  val to1 :
    t ->
    Device.t ->
    t

  val to2 :
    t ->
    Device.t ->
    Kind.t ->
    bool ->
    t

  val to3 :
    t ->
    Kind.t ->
    bool ->
    t

  val to4 :
    t ->
    Device.t ->
    bool ->
    t

  val to5 :
    t ->
    t ->
    bool ->
    t

  val to_dense :
    t ->
    t

  val totype :
    t ->
    Kind.t ->
    t

  val transpose :
    t ->
    int ->
    int ->
    t

  val transpose_ :
    t ->
    int ->
    int ->
    t

  val tril :
    t ->
    int ->
    t

  val tril_ :
    t ->
    int ->
    t

  val tril_out :
    t ->
    t ->
    int ->
    t

  val triplet_margin_loss :
    t ->
    t ->
    t ->
    float ->
    float ->
    float ->
    bool ->
    int ->
    t

  val triu :
    t ->
    int ->
    t

  val triu_ :
    t ->
    int ->
    t

  val triu_out :
    t ->
    t ->
    int ->
    t

  val trunc :
    t ->
    t

  val trunc_ :
    t ->
    t

  val trunc_out :
    t ->
    t ->
    t

  val type_as :
    t ->
    t ->
    t

  val unfold :
    t ->
    int ->
    int ->
    int ->
    t

  val uniform_ :
    t ->
    float ->
    float ->
    t

  val unsqueeze :
    t ->
    int ->
    t

  val unsqueeze_ :
    t ->
    int ->
    t

  val upsample_bilinear2d :
    t ->
    int list ->
    bool ->
    t

  val upsample_bilinear2d_backward :
    t ->
    int list ->
    int list ->
    bool ->
    t

  val upsample_bilinear2d_backward_out :
    t ->
    t ->
    int list ->
    int list ->
    bool ->
    t

  val upsample_bilinear2d_forward :
    t ->
    int list ->
    bool ->
    t

  val upsample_bilinear2d_forward_out :
    t ->
    t ->
    int list ->
    bool ->
    t

  val upsample_bilinear2d_out :
    t ->
    t ->
    int list ->
    bool ->
    t

  val upsample_linear1d :
    t ->
    int list ->
    bool ->
    t

  val upsample_linear1d_backward :
    t ->
    int list ->
    int list ->
    bool ->
    t

  val upsample_linear1d_backward_out :
    t ->
    t ->
    int list ->
    int list ->
    bool ->
    t

  val upsample_linear1d_forward :
    t ->
    int list ->
    bool ->
    t

  val upsample_linear1d_forward_out :
    t ->
    t ->
    int list ->
    bool ->
    t

  val upsample_linear1d_out :
    t ->
    t ->
    int list ->
    bool ->
    t

  val upsample_nearest1d :
    t ->
    int list ->
    t

  val upsample_nearest1d_backward :
    t ->
    int list ->
    int list ->
    t

  val upsample_nearest1d_backward_out :
    t ->
    t ->
    int list ->
    int list ->
    t

  val upsample_nearest1d_forward :
    t ->
    int list ->
    t

  val upsample_nearest1d_forward_out :
    t ->
    t ->
    int list ->
    t

  val upsample_nearest1d_out :
    t ->
    t ->
    int list ->
    t

  val upsample_nearest2d :
    t ->
    int list ->
    t

  val upsample_nearest2d_backward :
    t ->
    int list ->
    int list ->
    t

  val upsample_nearest2d_backward_out :
    t ->
    t ->
    int list ->
    int list ->
    t

  val upsample_nearest2d_forward :
    t ->
    int list ->
    t

  val upsample_nearest2d_forward_out :
    t ->
    t ->
    int list ->
    t

  val upsample_nearest2d_out :
    t ->
    t ->
    int list ->
    t

  val upsample_nearest3d :
    t ->
    int list ->
    t

  val upsample_nearest3d_backward :
    t ->
    int list ->
    int list ->
    t

  val upsample_nearest3d_backward_out :
    t ->
    t ->
    int list ->
    int list ->
    t

  val upsample_nearest3d_forward :
    t ->
    int list ->
    t

  val upsample_nearest3d_forward_out :
    t ->
    t ->
    int list ->
    t

  val upsample_nearest3d_out :
    t ->
    t ->
    int list ->
    t

  val upsample_trilinear3d :
    t ->
    int list ->
    bool ->
    t

  val upsample_trilinear3d_backward :
    t ->
    int list ->
    int list ->
    bool ->
    t

  val upsample_trilinear3d_backward_out :
    t ->
    t ->
    int list ->
    int list ->
    bool ->
    t

  val upsample_trilinear3d_forward :
    t ->
    int list ->
    bool ->
    t

  val upsample_trilinear3d_forward_out :
    t ->
    t ->
    int list ->
    bool ->
    t

  val upsample_trilinear3d_out :
    t ->
    t ->
    int list ->
    bool ->
    t

  val var1 :
    t ->
    bool ->
    t

  val var2 :
    t ->
    int ->
    bool ->
    bool ->
    t

  val var_out :
    t ->
    t ->
    int ->
    bool ->
    bool ->
    t

  val view :
    t ->
    int list ->
    t

  val view_as :
    t ->
    t ->
    t

  val where :
    t ->
    t ->
    t ->
    t

  val zero_ :
    t ->
    t

  val zeros :
    int list ->
    Kind.t * Device.t ->
    t

  val zeros_like1 :
    t ->
    t

  val zeros_like2 :
    t ->
    Kind.t * Device.t ->
    t

  val zeros_out :
    t ->
    int list ->
    t

end
