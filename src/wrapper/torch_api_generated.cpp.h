
// THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT BY HAND!

tensor atg_RoiPooling2d_backward(tensor input, tensor rois, int64_t pooledHeight, int64_t pooledWidth, double spatialScale, tensor gradOutput, tensor argmaxes) {
  PROTECT(
    return new torch::Tensor(torch::RoiPooling2d_backward(*input, *rois, pooledHeight, pooledWidth, spatialScale, *gradOutput, *argmaxes));
  )
}

tensor atg_abs(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::abs(*self));
  )
}

tensor atg_abs_(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::abs_(*self));
  )
}

tensor atg_abs_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::abs_out(*result, *self));
  )
}

tensor atg_acos(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::acos(*self));
  )
}

tensor atg_acos_(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::acos_(*self));
  )
}

tensor atg_acos_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::acos_out(*result, *self));
  )
}

tensor atg_adaptive_avg_pool1d(tensor self, int *output_size_data, int output_size_len) {
  PROTECT(
    return new torch::Tensor(torch::adaptive_avg_pool1d(*self, of_carray(output_size_data, output_size_len)));
  )
}

tensor atg_add(tensor self, tensor other) {
  PROTECT(
    return new torch::Tensor(torch::add(*self, *other));
  )
}

tensor atg_add_out(tensor result, tensor self, tensor other) {
  PROTECT(
    return new torch::Tensor(torch::add_out(*result, *self, *other));
  )
}

tensor atg_addmm(tensor self, tensor mat1, tensor mat2) {
  PROTECT(
    return new torch::Tensor(torch::addmm(*self, *mat1, *mat2));
  )
}

tensor atg_addmm_out(tensor result, tensor self, tensor mat1, tensor mat2) {
  PROTECT(
    return new torch::Tensor(torch::addmm_out(*result, *self, *mat1, *mat2));
  )
}

tensor atg_addmv(tensor self, tensor mat, tensor vec) {
  PROTECT(
    return new torch::Tensor(torch::addmv(*self, *mat, *vec));
  )
}

tensor atg_addmv_(tensor self, tensor mat, tensor vec) {
  PROTECT(
    return new torch::Tensor(torch::addmv_(*self, *mat, *vec));
  )
}

tensor atg_addmv_out(tensor result, tensor self, tensor mat, tensor vec) {
  PROTECT(
    return new torch::Tensor(torch::addmv_out(*result, *self, *mat, *vec));
  )
}

tensor atg_addr(tensor self, tensor vec1, tensor vec2) {
  PROTECT(
    return new torch::Tensor(torch::addr(*self, *vec1, *vec2));
  )
}

tensor atg_addr_out(tensor result, tensor self, tensor vec1, tensor vec2) {
  PROTECT(
    return new torch::Tensor(torch::addr_out(*result, *self, *vec1, *vec2));
  )
}

tensor atg_all(tensor self, int64_t dim, int keepdim) {
  PROTECT(
    return new torch::Tensor(torch::all(*self, dim, (bool)keepdim));
  )
}

tensor atg_all_out(tensor result, tensor self, int64_t dim, int keepdim) {
  PROTECT(
    return new torch::Tensor(torch::all_out(*result, *self, dim, (bool)keepdim));
  )
}

tensor atg_alpha_dropout(tensor input, double p, int train) {
  PROTECT(
    return new torch::Tensor(torch::alpha_dropout(*input, p, (bool)train));
  )
}

tensor atg_alpha_dropout_(tensor self, double p, int train) {
  PROTECT(
    return new torch::Tensor(torch::alpha_dropout_(*self, p, (bool)train));
  )
}

tensor atg_any(tensor self, int64_t dim, int keepdim) {
  PROTECT(
    return new torch::Tensor(torch::any(*self, dim, (bool)keepdim));
  )
}

tensor atg_any_out(tensor result, tensor self, int64_t dim, int keepdim) {
  PROTECT(
    return new torch::Tensor(torch::any_out(*result, *self, dim, (bool)keepdim));
  )
}

tensor atg_argmax1(tensor self, int64_t dim, int keepdim) {
  PROTECT(
    return new torch::Tensor(torch::argmax(*self, dim, (bool)keepdim));
  )
}

tensor atg_argmax2(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::argmax(*self));
  )
}

tensor atg_argmin1(tensor self, int64_t dim, int keepdim) {
  PROTECT(
    return new torch::Tensor(torch::argmin(*self, dim, (bool)keepdim));
  )
}

tensor atg_argmin2(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::argmin(*self));
  )
}

tensor atg_as_strided1(tensor self, int *size_data, int size_len, int *stride_data, int stride_len) {
  PROTECT(
    return new torch::Tensor(torch::as_strided(*self, of_carray(size_data, size_len), of_carray(stride_data, stride_len)));
  )
}

tensor atg_as_strided2(tensor self, int *size_data, int size_len, int *stride_data, int stride_len, int64_t storage_offset) {
  PROTECT(
    return new torch::Tensor(torch::as_strided(*self, of_carray(size_data, size_len), of_carray(stride_data, stride_len), storage_offset));
  )
}

tensor atg_as_strided_1(tensor self, int *size_data, int size_len, int *stride_data, int stride_len) {
  PROTECT(
    return new torch::Tensor(torch::as_strided_(*self, of_carray(size_data, size_len), of_carray(stride_data, stride_len)));
  )
}

tensor atg_as_strided_2(tensor self, int *size_data, int size_len, int *stride_data, int stride_len, int64_t storage_offset) {
  PROTECT(
    return new torch::Tensor(torch::as_strided_(*self, of_carray(size_data, size_len), of_carray(stride_data, stride_len), storage_offset));
  )
}

tensor atg_asin(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::asin(*self));
  )
}

tensor atg_asin_(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::asin_(*self));
  )
}

tensor atg_asin_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::asin_out(*result, *self));
  )
}

tensor atg_atan(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::atan(*self));
  )
}

tensor atg_atan_(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::atan_(*self));
  )
}

tensor atg_atan_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::atan_out(*result, *self));
  )
}

tensor atg_avg_pool1d(tensor self, int *kernel_size_data, int kernel_size_len, int *stride_data, int stride_len, int *padding_data, int padding_len, int ceil_mode, int count_include_pad) {
  PROTECT(
    return new torch::Tensor(torch::avg_pool1d(*self, of_carray(kernel_size_data, kernel_size_len), of_carray(stride_data, stride_len), of_carray(padding_data, padding_len), (bool)ceil_mode, (bool)count_include_pad));
  )
}

tensor atg_baddbmm(tensor self, tensor batch1, tensor batch2) {
  PROTECT(
    return new torch::Tensor(torch::baddbmm(*self, *batch1, *batch2));
  )
}

tensor atg_baddbmm_out(tensor result, tensor self, tensor batch1, tensor batch2) {
  PROTECT(
    return new torch::Tensor(torch::baddbmm_out(*result, *self, *batch1, *batch2));
  )
}

tensor atg_bartlett_window1(int64_t window_length) {
  PROTECT(
    return new torch::Tensor(torch::bartlett_window(window_length));
  )
}

tensor atg_bartlett_window2(int64_t window_length, int periodic) {
  PROTECT(
    return new torch::Tensor(torch::bartlett_window(window_length, (bool)periodic));
  )
}

tensor atg_bernoulli1(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::bernoulli(*self));
  )
}

tensor atg_bernoulli2(tensor self, double p) {
  PROTECT(
    return new torch::Tensor(torch::bernoulli(*self, p));
  )
}

tensor atg_bernoulli_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::bernoulli_out(*result, *self));
  )
}

tensor atg_blackman_window1(int64_t window_length) {
  PROTECT(
    return new torch::Tensor(torch::blackman_window(window_length));
  )
}

tensor atg_blackman_window2(int64_t window_length, int periodic) {
  PROTECT(
    return new torch::Tensor(torch::blackman_window(window_length, (bool)periodic));
  )
}

tensor atg_bmm(tensor self, tensor mat2) {
  PROTECT(
    return new torch::Tensor(torch::bmm(*self, *mat2));
  )
}

tensor atg_bmm_out(tensor result, tensor self, tensor mat2) {
  PROTECT(
    return new torch::Tensor(torch::bmm_out(*result, *self, *mat2));
  )
}

tensor atg_ceil(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::ceil(*self));
  )
}

tensor atg_ceil_(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::ceil_(*self));
  )
}

tensor atg_ceil_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::ceil_out(*result, *self));
  )
}

tensor atg_celu(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::celu(*self));
  )
}

tensor atg_celu_(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::celu_(*self));
  )
}

tensor atg_clone(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::clone(*self));
  )
}

tensor atg_conv1d(tensor input, tensor weight, tensor bias, int *stride_data, int stride_len, int *padding_data, int padding_len, int *dilation_data, int dilation_len, int64_t groups) {
  PROTECT(
    return new torch::Tensor(torch::conv1d(*input, *weight, *bias, of_carray(stride_data, stride_len), of_carray(padding_data, padding_len), of_carray(dilation_data, dilation_len), groups));
  )
}

tensor atg_conv2d(tensor input, tensor weight, tensor bias, int *stride_data, int stride_len, int *padding_data, int padding_len, int *dilation_data, int dilation_len, int64_t groups) {
  PROTECT(
    return new torch::Tensor(torch::conv2d(*input, *weight, *bias, of_carray(stride_data, stride_len), of_carray(padding_data, padding_len), of_carray(dilation_data, dilation_len), groups));
  )
}

tensor atg_conv3d(tensor input, tensor weight, tensor bias, int *stride_data, int stride_len, int *padding_data, int padding_len, int *dilation_data, int dilation_len, int64_t groups) {
  PROTECT(
    return new torch::Tensor(torch::conv3d(*input, *weight, *bias, of_carray(stride_data, stride_len), of_carray(padding_data, padding_len), of_carray(dilation_data, dilation_len), groups));
  )
}

tensor atg_conv_tbc(tensor self, tensor weight, tensor bias, int64_t pad) {
  PROTECT(
    return new torch::Tensor(torch::conv_tbc(*self, *weight, *bias, pad));
  )
}

tensor atg_conv_transpose1d(tensor input, tensor weight, tensor bias, int *stride_data, int stride_len, int *padding_data, int padding_len, int *output_padding_data, int output_padding_len, int64_t groups, int *dilation_data, int dilation_len) {
  PROTECT(
    return new torch::Tensor(torch::conv_transpose1d(*input, *weight, *bias, of_carray(stride_data, stride_len), of_carray(padding_data, padding_len), of_carray(output_padding_data, output_padding_len), groups, of_carray(dilation_data, dilation_len)));
  )
}

tensor atg_conv_transpose2d(tensor input, tensor weight, tensor bias, int *stride_data, int stride_len, int *padding_data, int padding_len, int *output_padding_data, int output_padding_len, int64_t groups, int *dilation_data, int dilation_len) {
  PROTECT(
    return new torch::Tensor(torch::conv_transpose2d(*input, *weight, *bias, of_carray(stride_data, stride_len), of_carray(padding_data, padding_len), of_carray(output_padding_data, output_padding_len), groups, of_carray(dilation_data, dilation_len)));
  )
}

tensor atg_conv_transpose3d(tensor input, tensor weight, tensor bias, int *stride_data, int stride_len, int *padding_data, int padding_len, int *output_padding_data, int output_padding_len, int64_t groups, int *dilation_data, int dilation_len) {
  PROTECT(
    return new torch::Tensor(torch::conv_transpose3d(*input, *weight, *bias, of_carray(stride_data, stride_len), of_carray(padding_data, padding_len), of_carray(output_padding_data, output_padding_len), groups, of_carray(dilation_data, dilation_len)));
  )
}

tensor atg_copy_sparse_to_sparse_(tensor self, tensor src, int non_blocking) {
  PROTECT(
    return new torch::Tensor(torch::copy_sparse_to_sparse_(*self, *src, (bool)non_blocking));
  )
}

tensor atg_cos(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::cos(*self));
  )
}

tensor atg_cos_(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::cos_(*self));
  )
}

tensor atg_cos_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::cos_out(*result, *self));
  )
}

tensor atg_cosh(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::cosh(*self));
  )
}

tensor atg_cosh_(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::cosh_(*self));
  )
}

tensor atg_cosh_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::cosh_out(*result, *self));
  )
}

tensor atg_cosine_embedding_loss(tensor input1, tensor input2, tensor target, double margin, int64_t reduction) {
  PROTECT(
    return new torch::Tensor(torch::cosine_embedding_loss(*input1, *input2, *target, margin, reduction));
  )
}

tensor atg_ctc_loss1(tensor log_probs, tensor targets, int *input_lengths_data, int input_lengths_len, int *target_lengths_data, int target_lengths_len, int64_t blank, int64_t reduction) {
  PROTECT(
    return new torch::Tensor(torch::ctc_loss(*log_probs, *targets, of_carray(input_lengths_data, input_lengths_len), of_carray(target_lengths_data, target_lengths_len), blank, reduction));
  )
}

tensor atg_ctc_loss2(tensor log_probs, tensor targets, tensor input_lengths, tensor target_lengths, int64_t blank, int64_t reduction) {
  PROTECT(
    return new torch::Tensor(torch::ctc_loss(*log_probs, *targets, *input_lengths, *target_lengths, blank, reduction));
  )
}

tensor atg_cudnn_affine_grid_generator(tensor theta, int64_t N, int64_t C, int64_t H, int64_t W) {
  PROTECT(
    return new torch::Tensor(torch::cudnn_affine_grid_generator(*theta, N, C, H, W));
  )
}

tensor atg_cudnn_convolution_backward_bias(tensor grad_output) {
  PROTECT(
    return new torch::Tensor(torch::cudnn_convolution_backward_bias(*grad_output));
  )
}

tensor atg_cudnn_convolution_backward_input(int *self_size_data, int self_size_len, tensor grad_output, tensor weight, int *padding_data, int padding_len, int *stride_data, int stride_len, int *dilation_data, int dilation_len, int64_t groups, int benchmark, int deterministic) {
  PROTECT(
    return new torch::Tensor(torch::cudnn_convolution_backward_input(of_carray(self_size_data, self_size_len), *grad_output, *weight, of_carray(padding_data, padding_len), of_carray(stride_data, stride_len), of_carray(dilation_data, dilation_len), groups, (bool)benchmark, (bool)deterministic));
  )
}

tensor atg_cudnn_convolution_backward_weight(int *weight_size_data, int weight_size_len, tensor grad_output, tensor self, int *padding_data, int padding_len, int *stride_data, int stride_len, int *dilation_data, int dilation_len, int64_t groups, int benchmark, int deterministic) {
  PROTECT(
    return new torch::Tensor(torch::cudnn_convolution_backward_weight(of_carray(weight_size_data, weight_size_len), *grad_output, *self, of_carray(padding_data, padding_len), of_carray(stride_data, stride_len), of_carray(dilation_data, dilation_len), groups, (bool)benchmark, (bool)deterministic));
  )
}

tensor atg_cudnn_convolution_transpose_backward_bias(tensor grad_output) {
  PROTECT(
    return new torch::Tensor(torch::cudnn_convolution_transpose_backward_bias(*grad_output));
  )
}

tensor atg_cudnn_convolution_transpose_backward_input(tensor grad_output, tensor weight, int *padding_data, int padding_len, int *stride_data, int stride_len, int *dilation_data, int dilation_len, int64_t groups, int benchmark, int deterministic) {
  PROTECT(
    return new torch::Tensor(torch::cudnn_convolution_transpose_backward_input(*grad_output, *weight, of_carray(padding_data, padding_len), of_carray(stride_data, stride_len), of_carray(dilation_data, dilation_len), groups, (bool)benchmark, (bool)deterministic));
  )
}

tensor atg_cudnn_convolution_transpose_backward_weight(int *weight_size_data, int weight_size_len, tensor grad_output, tensor self, int *padding_data, int padding_len, int *stride_data, int stride_len, int *dilation_data, int dilation_len, int64_t groups, int benchmark, int deterministic) {
  PROTECT(
    return new torch::Tensor(torch::cudnn_convolution_transpose_backward_weight(of_carray(weight_size_data, weight_size_len), *grad_output, *self, of_carray(padding_data, padding_len), of_carray(stride_data, stride_len), of_carray(dilation_data, dilation_len), groups, (bool)benchmark, (bool)deterministic));
  )
}

tensor atg_cumprod(tensor self, int64_t dim) {
  PROTECT(
    return new torch::Tensor(torch::cumprod(*self, dim));
  )
}

tensor atg_cumprod_out(tensor result, tensor self, int64_t dim) {
  PROTECT(
    return new torch::Tensor(torch::cumprod_out(*result, *self, dim));
  )
}

tensor atg_cumsum(tensor self, int64_t dim) {
  PROTECT(
    return new torch::Tensor(torch::cumsum(*self, dim));
  )
}

tensor atg_cumsum_out(tensor result, tensor self, int64_t dim) {
  PROTECT(
    return new torch::Tensor(torch::cumsum_out(*result, *self, dim));
  )
}

tensor atg_det(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::det(*self));
  )
}

tensor atg_detach(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::detach(*self));
  )
}

tensor atg_detach_(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::detach_(*self));
  )
}

tensor atg_diagflat(tensor self, int64_t offset) {
  PROTECT(
    return new torch::Tensor(torch::diagflat(*self, offset));
  )
}

tensor atg_diagonal(tensor self, int64_t offset, int64_t dim1, int64_t dim2) {
  PROTECT(
    return new torch::Tensor(torch::diagonal(*self, offset, dim1, dim2));
  )
}

tensor atg_div(tensor self, tensor other) {
  PROTECT(
    return new torch::Tensor(torch::div(*self, *other));
  )
}

tensor atg_div_out(tensor result, tensor self, tensor other) {
  PROTECT(
    return new torch::Tensor(torch::div_out(*result, *self, *other));
  )
}

tensor atg_dot(tensor self, tensor tensor) {
  PROTECT(
    return new torch::Tensor(torch::dot(*self, *tensor));
  )
}

tensor atg_dot_out(tensor result, tensor self, tensor tensor) {
  PROTECT(
    return new torch::Tensor(torch::dot_out(*result, *self, *tensor));
  )
}

tensor atg_dropout(tensor input, double p, int train) {
  PROTECT(
    return new torch::Tensor(torch::dropout(*input, p, (bool)train));
  )
}

tensor atg_dropout_(tensor self, double p, int train) {
  PROTECT(
    return new torch::Tensor(torch::dropout_(*self, p, (bool)train));
  )
}

tensor atg_empty(int *size_data, int size_len) {
  PROTECT(
    return new torch::Tensor(torch::empty(of_carray(size_data, size_len)));
  )
}

tensor atg_empty_like(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::empty_like(*self));
  )
}

tensor atg_empty_out(tensor result, int *size_data, int size_len) {
  PROTECT(
    return new torch::Tensor(torch::empty_out(*result, of_carray(size_data, size_len)));
  )
}

tensor atg_empty_strided(int *size_data, int size_len, int *stride_data, int stride_len) {
  PROTECT(
    return new torch::Tensor(torch::empty_strided(of_carray(size_data, size_len), of_carray(stride_data, stride_len)));
  )
}

tensor atg_erf(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::erf(*self));
  )
}

tensor atg_erf_(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::erf_(*self));
  )
}

tensor atg_erf_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::erf_out(*result, *self));
  )
}

tensor atg_erfc(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::erfc(*self));
  )
}

tensor atg_erfc_(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::erfc_(*self));
  )
}

tensor atg_erfc_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::erfc_out(*result, *self));
  )
}

tensor atg_exp(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::exp(*self));
  )
}

tensor atg_exp_(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::exp_(*self));
  )
}

tensor atg_exp_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::exp_out(*result, *self));
  )
}

tensor atg_expm1(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::expm1(*self));
  )
}

tensor atg_expm1_(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::expm1_(*self));
  )
}

tensor atg_expm1_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::expm1_out(*result, *self));
  )
}

tensor atg_eye1(int64_t n) {
  PROTECT(
    return new torch::Tensor(torch::eye(n));
  )
}

tensor atg_eye2(int64_t n, int64_t m) {
  PROTECT(
    return new torch::Tensor(torch::eye(n, m));
  )
}

tensor atg_eye_out1(tensor result, int64_t n) {
  PROTECT(
    return new torch::Tensor(torch::eye_out(*result, n));
  )
}

tensor atg_eye_out2(tensor result, int64_t n, int64_t m) {
  PROTECT(
    return new torch::Tensor(torch::eye_out(*result, n, m));
  )
}

tensor atg_feature_alpha_dropout(tensor input, double p, int train) {
  PROTECT(
    return new torch::Tensor(torch::feature_alpha_dropout(*input, p, (bool)train));
  )
}

tensor atg_feature_alpha_dropout_(tensor self, double p, int train) {
  PROTECT(
    return new torch::Tensor(torch::feature_alpha_dropout_(*self, p, (bool)train));
  )
}

tensor atg_feature_dropout(tensor input, double p, int train) {
  PROTECT(
    return new torch::Tensor(torch::feature_dropout(*input, p, (bool)train));
  )
}

tensor atg_feature_dropout_(tensor self, double p, int train) {
  PROTECT(
    return new torch::Tensor(torch::feature_dropout_(*self, p, (bool)train));
  )
}

tensor atg_fft(tensor self, int64_t signal_ndim, int normalized) {
  PROTECT(
    return new torch::Tensor(torch::fft(*self, signal_ndim, (bool)normalized));
  )
}

tensor atg_fill_(tensor self, tensor value) {
  PROTECT(
    return new torch::Tensor(torch::fill_(*self, *value));
  )
}

tensor atg_flatten(tensor self, int64_t start_dim, int64_t end_dim) {
  PROTECT(
    return new torch::Tensor(torch::flatten(*self, start_dim, end_dim));
  )
}

tensor atg_flip(tensor self, int *dims_data, int dims_len) {
  PROTECT(
    return new torch::Tensor(torch::flip(*self, of_carray(dims_data, dims_len)));
  )
}

tensor atg_floor(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::floor(*self));
  )
}

tensor atg_floor_(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::floor_(*self));
  )
}

tensor atg_floor_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::floor_out(*result, *self));
  )
}

tensor atg_frobenius_norm1(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::frobenius_norm(*self));
  )
}

tensor atg_frobenius_norm2(tensor self, int *dim_data, int dim_len, int keepdim) {
  PROTECT(
    return new torch::Tensor(torch::frobenius_norm(*self, of_carray(dim_data, dim_len), (bool)keepdim));
  )
}

tensor atg_frobenius_norm_out(tensor result, tensor self, int *dim_data, int dim_len, int keepdim) {
  PROTECT(
    return new torch::Tensor(torch::frobenius_norm_out(*result, *self, of_carray(dim_data, dim_len), (bool)keepdim));
  )
}

tensor atg_ger(tensor self, tensor vec2) {
  PROTECT(
    return new torch::Tensor(torch::ger(*self, *vec2));
  )
}

tensor atg_ger_out(tensor result, tensor self, tensor vec2) {
  PROTECT(
    return new torch::Tensor(torch::ger_out(*result, *self, *vec2));
  )
}

tensor atg_grid_sampler(tensor input, tensor grid, int64_t interpolation_mode, int64_t padding_mode) {
  PROTECT(
    return new torch::Tensor(torch::grid_sampler(*input, *grid, interpolation_mode, padding_mode));
  )
}

tensor atg_grid_sampler_2d(tensor input, tensor grid, int64_t interpolation_mode, int64_t padding_mode) {
  PROTECT(
    return new torch::Tensor(torch::grid_sampler_2d(*input, *grid, interpolation_mode, padding_mode));
  )
}

tensor atg_grid_sampler_3d(tensor input, tensor grid, int64_t interpolation_mode, int64_t padding_mode) {
  PROTECT(
    return new torch::Tensor(torch::grid_sampler_3d(*input, *grid, interpolation_mode, padding_mode));
  )
}

tensor atg_gru_cell(tensor input, tensor hx, tensor w_ih, tensor w_hh) {
  PROTECT(
    return new torch::Tensor(torch::gru_cell(*input, *hx, *w_ih, *w_hh));
  )
}

tensor atg_hamming_window1(int64_t window_length) {
  PROTECT(
    return new torch::Tensor(torch::hamming_window(window_length));
  )
}

tensor atg_hamming_window2(int64_t window_length, int periodic) {
  PROTECT(
    return new torch::Tensor(torch::hamming_window(window_length, (bool)periodic));
  )
}

tensor atg_hamming_window3(int64_t window_length, int periodic, double alpha) {
  PROTECT(
    return new torch::Tensor(torch::hamming_window(window_length, (bool)periodic, alpha));
  )
}

tensor atg_hamming_window4(int64_t window_length, int periodic, double alpha, double beta) {
  PROTECT(
    return new torch::Tensor(torch::hamming_window(window_length, (bool)periodic, alpha, beta));
  )
}

tensor atg_hann_window1(int64_t window_length) {
  PROTECT(
    return new torch::Tensor(torch::hann_window(window_length));
  )
}

tensor atg_hann_window2(int64_t window_length, int periodic) {
  PROTECT(
    return new torch::Tensor(torch::hann_window(window_length, (bool)periodic));
  )
}

tensor atg_hardshrink(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::hardshrink(*self));
  )
}

tensor atg_hinge_embedding_loss(tensor self, tensor target, double margin, int64_t reduction) {
  PROTECT(
    return new torch::Tensor(torch::hinge_embedding_loss(*self, *target, margin, reduction));
  )
}

tensor atg_hspmm(tensor mat1, tensor mat2) {
  PROTECT(
    return new torch::Tensor(torch::hspmm(*mat1, *mat2));
  )
}

tensor atg_hspmm_out(tensor result, tensor mat1, tensor mat2) {
  PROTECT(
    return new torch::Tensor(torch::hspmm_out(*result, *mat1, *mat2));
  )
}

tensor atg_ifft(tensor self, int64_t signal_ndim, int normalized) {
  PROTECT(
    return new torch::Tensor(torch::ifft(*self, signal_ndim, (bool)normalized));
  )
}

tensor atg_inverse(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::inverse(*self));
  )
}

tensor atg_inverse_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::inverse_out(*result, *self));
  )
}

tensor atg_irfft(tensor self, int64_t signal_ndim, int normalized, int onesided, int *signal_sizes_data, int signal_sizes_len) {
  PROTECT(
    return new torch::Tensor(torch::irfft(*self, signal_ndim, (bool)normalized, (bool)onesided, of_carray(signal_sizes_data, signal_sizes_len)));
  )
}

tensor atg_isclose(tensor self, tensor other, double rtol, double atol, int equal_nan) {
  PROTECT(
    return new torch::Tensor(torch::isclose(*self, *other, rtol, atol, (bool)equal_nan));
  )
}

tensor atg_kl_div(tensor self, tensor target, int64_t reduction) {
  PROTECT(
    return new torch::Tensor(torch::kl_div(*self, *target, reduction));
  )
}

tensor atg_kl_div_backward(tensor grad_output, tensor self, tensor target, int64_t reduction) {
  PROTECT(
    return new torch::Tensor(torch::kl_div_backward(*grad_output, *self, *target, reduction));
  )
}

tensor atg_linear(tensor input, tensor weight, tensor bias) {
  PROTECT(
    return new torch::Tensor(torch::linear(*input, *weight, *bias));
  )
}

tensor atg_log(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::log(*self));
  )
}

tensor atg_log10(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::log10(*self));
  )
}

tensor atg_log10_(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::log10_(*self));
  )
}

tensor atg_log10_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::log10_out(*result, *self));
  )
}

tensor atg_log1p(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::log1p(*self));
  )
}

tensor atg_log1p_(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::log1p_(*self));
  )
}

tensor atg_log1p_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::log1p_out(*result, *self));
  )
}

tensor atg_log2(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::log2(*self));
  )
}

tensor atg_log2_(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::log2_(*self));
  )
}

tensor atg_log2_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::log2_out(*result, *self));
  )
}

tensor atg_log_(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::log_(*self));
  )
}

tensor atg_log_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::log_out(*result, *self));
  )
}

tensor atg_log_softmax(tensor self, int64_t dim) {
  PROTECT(
    return new torch::Tensor(torch::log_softmax(*self, dim));
  )
}

tensor atg_log_softmax_backward_data(tensor grad_output, tensor output, int64_t dim, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::log_softmax_backward_data(*grad_output, *output, dim, *self));
  )
}

tensor atg_logdet(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::logdet(*self));
  )
}

tensor atg_logsumexp(tensor self, int64_t dim, int keepdim) {
  PROTECT(
    return new torch::Tensor(torch::logsumexp(*self, dim, (bool)keepdim));
  )
}

tensor atg_logsumexp_out(tensor result, tensor self, int64_t dim, int keepdim) {
  PROTECT(
    return new torch::Tensor(torch::logsumexp_out(*result, *self, dim, (bool)keepdim));
  )
}

tensor atg_margin_ranking_loss(tensor input1, tensor input2, tensor target, double margin, int64_t reduction) {
  PROTECT(
    return new torch::Tensor(torch::margin_ranking_loss(*input1, *input2, *target, margin, reduction));
  )
}

tensor atg_matmul(tensor self, tensor other) {
  PROTECT(
    return new torch::Tensor(torch::matmul(*self, *other));
  )
}

tensor atg_matmul_out(tensor result, tensor self, tensor other) {
  PROTECT(
    return new torch::Tensor(torch::matmul_out(*result, *self, *other));
  )
}

tensor atg_matrix_power(tensor self, int64_t n) {
  PROTECT(
    return new torch::Tensor(torch::matrix_power(*self, n));
  )
}

tensor atg_matrix_rank1(tensor self, double tol, int symmetric) {
  PROTECT(
    return new torch::Tensor(torch::matrix_rank(*self, tol, (bool)symmetric));
  )
}

tensor atg_matrix_rank2(tensor self, int symmetric) {
  PROTECT(
    return new torch::Tensor(torch::matrix_rank(*self, (bool)symmetric));
  )
}

tensor atg_max_pool1d(tensor self, int *kernel_size_data, int kernel_size_len, int *stride_data, int stride_len, int *padding_data, int padding_len, int *dilation_data, int dilation_len, int ceil_mode) {
  PROTECT(
    return new torch::Tensor(torch::max_pool1d(*self, of_carray(kernel_size_data, kernel_size_len), of_carray(stride_data, stride_len), of_carray(padding_data, padding_len), of_carray(dilation_data, dilation_len), (bool)ceil_mode));
  )
}

tensor atg_max_pool2d(tensor self, int *kernel_size_data, int kernel_size_len, int *stride_data, int stride_len, int *padding_data, int padding_len, int *dilation_data, int dilation_len, int ceil_mode) {
  PROTECT(
    return new torch::Tensor(torch::max_pool2d(*self, of_carray(kernel_size_data, kernel_size_len), of_carray(stride_data, stride_len), of_carray(padding_data, padding_len), of_carray(dilation_data, dilation_len), (bool)ceil_mode));
  )
}

tensor atg_max_pool3d(tensor self, int *kernel_size_data, int kernel_size_len, int *stride_data, int stride_len, int *padding_data, int padding_len, int *dilation_data, int dilation_len, int ceil_mode) {
  PROTECT(
    return new torch::Tensor(torch::max_pool3d(*self, of_carray(kernel_size_data, kernel_size_len), of_carray(stride_data, stride_len), of_carray(padding_data, padding_len), of_carray(dilation_data, dilation_len), (bool)ceil_mode));
  )
}

tensor atg_max_values(tensor self, int64_t dim, int keepdim) {
  PROTECT(
    return new torch::Tensor(torch::max_values(*self, dim, (bool)keepdim));
  )
}

tensor atg_mean1(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::mean(*self));
  )
}

tensor atg_mean2(tensor self, int64_t dim, int keepdim) {
  PROTECT(
    return new torch::Tensor(torch::mean(*self, dim, (bool)keepdim));
  )
}

tensor atg_mean_out(tensor result, tensor self, int64_t dim, int keepdim) {
  PROTECT(
    return new torch::Tensor(torch::mean_out(*result, *self, dim, (bool)keepdim));
  )
}

tensor atg_min_values(tensor self, int64_t dim, int keepdim) {
  PROTECT(
    return new torch::Tensor(torch::min_values(*self, dim, (bool)keepdim));
  )
}

tensor atg_miopen_convolution_backward_bias(tensor grad_output) {
  PROTECT(
    return new torch::Tensor(torch::miopen_convolution_backward_bias(*grad_output));
  )
}

tensor atg_miopen_convolution_backward_input(int *self_size_data, int self_size_len, tensor grad_output, tensor weight, int *padding_data, int padding_len, int *stride_data, int stride_len, int *dilation_data, int dilation_len, int64_t groups, int benchmark, int deterministic) {
  PROTECT(
    return new torch::Tensor(torch::miopen_convolution_backward_input(of_carray(self_size_data, self_size_len), *grad_output, *weight, of_carray(padding_data, padding_len), of_carray(stride_data, stride_len), of_carray(dilation_data, dilation_len), groups, (bool)benchmark, (bool)deterministic));
  )
}

tensor atg_miopen_convolution_backward_weight(int *weight_size_data, int weight_size_len, tensor grad_output, tensor self, int *padding_data, int padding_len, int *stride_data, int stride_len, int *dilation_data, int dilation_len, int64_t groups, int benchmark, int deterministic) {
  PROTECT(
    return new torch::Tensor(torch::miopen_convolution_backward_weight(of_carray(weight_size_data, weight_size_len), *grad_output, *self, of_carray(padding_data, padding_len), of_carray(stride_data, stride_len), of_carray(dilation_data, dilation_len), groups, (bool)benchmark, (bool)deterministic));
  )
}

tensor atg_miopen_convolution_transpose_backward_input(tensor grad_output, tensor weight, int *padding_data, int padding_len, int *stride_data, int stride_len, int *dilation_data, int dilation_len, int64_t groups, int benchmark, int deterministic) {
  PROTECT(
    return new torch::Tensor(torch::miopen_convolution_transpose_backward_input(*grad_output, *weight, of_carray(padding_data, padding_len), of_carray(stride_data, stride_len), of_carray(dilation_data, dilation_len), groups, (bool)benchmark, (bool)deterministic));
  )
}

tensor atg_miopen_convolution_transpose_backward_weight(int *weight_size_data, int weight_size_len, tensor grad_output, tensor self, int *padding_data, int padding_len, int *stride_data, int stride_len, int *dilation_data, int dilation_len, int64_t groups, int benchmark, int deterministic) {
  PROTECT(
    return new torch::Tensor(torch::miopen_convolution_transpose_backward_weight(of_carray(weight_size_data, weight_size_len), *grad_output, *self, of_carray(padding_data, padding_len), of_carray(stride_data, stride_len), of_carray(dilation_data, dilation_len), groups, (bool)benchmark, (bool)deterministic));
  )
}

tensor atg_mkldnn_convolution_backward_input(int *self_size_data, int self_size_len, tensor grad_output, tensor weight, int *padding_data, int padding_len, int *stride_data, int stride_len, int *dilation_data, int dilation_len, int64_t groups, int bias_defined) {
  PROTECT(
    return new torch::Tensor(torch::mkldnn_convolution_backward_input(of_carray(self_size_data, self_size_len), *grad_output, *weight, of_carray(padding_data, padding_len), of_carray(stride_data, stride_len), of_carray(dilation_data, dilation_len), groups, (bool)bias_defined));
  )
}

tensor atg_mm(tensor self, tensor mat2) {
  PROTECT(
    return new torch::Tensor(torch::mm(*self, *mat2));
  )
}

tensor atg_mm_out(tensor result, tensor self, tensor mat2) {
  PROTECT(
    return new torch::Tensor(torch::mm_out(*result, *self, *mat2));
  )
}

tensor atg_mul(tensor self, tensor other) {
  PROTECT(
    return new torch::Tensor(torch::mul(*self, *other));
  )
}

tensor atg_mul_out(tensor result, tensor self, tensor other) {
  PROTECT(
    return new torch::Tensor(torch::mul_out(*result, *self, *other));
  )
}

tensor atg_mv(tensor self, tensor vec) {
  PROTECT(
    return new torch::Tensor(torch::mv(*self, *vec));
  )
}

tensor atg_mv_out(tensor result, tensor self, tensor vec) {
  PROTECT(
    return new torch::Tensor(torch::mv_out(*result, *self, *vec));
  )
}

tensor atg_mvlgamma(tensor self, int64_t p) {
  PROTECT(
    return new torch::Tensor(torch::mvlgamma(*self, p));
  )
}

tensor atg_narrow(tensor self, int64_t dim, int64_t start, int64_t length) {
  PROTECT(
    return new torch::Tensor(torch::narrow(*self, dim, start, length));
  )
}

tensor atg_native_clone(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::native_clone(*self));
  )
}

tensor atg_native_norm(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::native_norm(*self));
  )
}

tensor atg_native_resize_as_(tensor self, tensor the_template) {
  PROTECT(
    return new torch::Tensor(torch::native_resize_as_(*self, *the_template));
  )
}

tensor atg_native_zero_(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::native_zero_(*self));
  )
}

tensor atg_norm(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::norm(*self));
  )
}

tensor atg_norm_except_dim(tensor v, int64_t pow, int64_t dim) {
  PROTECT(
    return new torch::Tensor(torch::norm_except_dim(*v, pow, dim));
  )
}

tensor atg_nuclear_norm(tensor self, int keepdim) {
  PROTECT(
    return new torch::Tensor(torch::nuclear_norm(*self, (bool)keepdim));
  )
}

tensor atg_nuclear_norm_out(tensor result, tensor self, int keepdim) {
  PROTECT(
    return new torch::Tensor(torch::nuclear_norm_out(*result, *self, (bool)keepdim));
  )
}

tensor atg_ones(int *size_data, int size_len) {
  PROTECT(
    return new torch::Tensor(torch::ones(of_carray(size_data, size_len)));
  )
}

tensor atg_ones_like(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::ones_like(*self));
  )
}

tensor atg_ones_out(tensor result, int *size_data, int size_len) {
  PROTECT(
    return new torch::Tensor(torch::ones_out(*result, of_carray(size_data, size_len)));
  )
}

tensor atg_pairwise_distance(tensor x1, tensor x2, double p, double eps, int keepdim) {
  PROTECT(
    return new torch::Tensor(torch::pairwise_distance(*x1, *x2, p, eps, (bool)keepdim));
  )
}

tensor atg_pdist(tensor self, double p) {
  PROTECT(
    return new torch::Tensor(torch::pdist(*self, p));
  )
}

tensor atg_pin_memory(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::pin_memory(*self));
  )
}

tensor atg_pinverse(tensor self, double rcond) {
  PROTECT(
    return new torch::Tensor(torch::pinverse(*self, rcond));
  )
}

tensor atg_pixel_shuffle(tensor self, int64_t upscale_factor) {
  PROTECT(
    return new torch::Tensor(torch::pixel_shuffle(*self, upscale_factor));
  )
}

tensor atg_poisson(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::poisson(*self));
  )
}

tensor atg_prelu(tensor self, tensor weight) {
  PROTECT(
    return new torch::Tensor(torch::prelu(*self, *weight));
  )
}

tensor atg_prod1(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::prod(*self));
  )
}

tensor atg_prod2(tensor self, int64_t dim, int keepdim) {
  PROTECT(
    return new torch::Tensor(torch::prod(*self, dim, (bool)keepdim));
  )
}

tensor atg_prod_out(tensor result, tensor self, int64_t dim, int keepdim) {
  PROTECT(
    return new torch::Tensor(torch::prod_out(*result, *self, dim, (bool)keepdim));
  )
}

tensor atg_rand(int *size_data, int size_len) {
  PROTECT(
    return new torch::Tensor(torch::rand(of_carray(size_data, size_len)));
  )
}

tensor atg_rand_like(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::rand_like(*self));
  )
}

tensor atg_rand_out(tensor result, int *size_data, int size_len) {
  PROTECT(
    return new torch::Tensor(torch::rand_out(*result, of_carray(size_data, size_len)));
  )
}

tensor atg_randint1(int64_t high, int *size_data, int size_len) {
  PROTECT(
    return new torch::Tensor(torch::randint(high, of_carray(size_data, size_len)));
  )
}

tensor atg_randint2(int64_t low, int64_t high, int *size_data, int size_len) {
  PROTECT(
    return new torch::Tensor(torch::randint(low, high, of_carray(size_data, size_len)));
  )
}

tensor atg_randint_like1(tensor self, int64_t high) {
  PROTECT(
    return new torch::Tensor(torch::randint_like(*self, high));
  )
}

tensor atg_randint_like2(tensor self, int64_t low, int64_t high) {
  PROTECT(
    return new torch::Tensor(torch::randint_like(*self, low, high));
  )
}

tensor atg_randint_out1(tensor result, int64_t high, int *size_data, int size_len) {
  PROTECT(
    return new torch::Tensor(torch::randint_out(*result, high, of_carray(size_data, size_len)));
  )
}

tensor atg_randint_out2(tensor result, int64_t low, int64_t high, int *size_data, int size_len) {
  PROTECT(
    return new torch::Tensor(torch::randint_out(*result, low, high, of_carray(size_data, size_len)));
  )
}

tensor atg_randn(int *size_data, int size_len) {
  PROTECT(
    return new torch::Tensor(torch::randn(of_carray(size_data, size_len)));
  )
}

tensor atg_randn_like(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::randn_like(*self));
  )
}

tensor atg_randn_out(tensor result, int *size_data, int size_len) {
  PROTECT(
    return new torch::Tensor(torch::randn_out(*result, of_carray(size_data, size_len)));
  )
}

tensor atg_randperm(int64_t n) {
  PROTECT(
    return new torch::Tensor(torch::randperm(n));
  )
}

tensor atg_randperm_out(tensor result, int64_t n) {
  PROTECT(
    return new torch::Tensor(torch::randperm_out(*result, n));
  )
}

tensor atg_relu(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::relu(*self));
  )
}

tensor atg_relu_(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::relu_(*self));
  )
}

tensor atg_reshape(tensor self, int *shape_data, int shape_len) {
  PROTECT(
    return new torch::Tensor(torch::reshape(*self, of_carray(shape_data, shape_len)));
  )
}

tensor atg_resize_as_(tensor self, tensor the_template) {
  PROTECT(
    return new torch::Tensor(torch::resize_as_(*self, *the_template));
  )
}

tensor atg_rfft(tensor self, int64_t signal_ndim, int normalized, int onesided) {
  PROTECT(
    return new torch::Tensor(torch::rfft(*self, signal_ndim, (bool)normalized, (bool)onesided));
  )
}

tensor atg_rnn_relu_cell(tensor input, tensor hx, tensor w_ih, tensor w_hh) {
  PROTECT(
    return new torch::Tensor(torch::rnn_relu_cell(*input, *hx, *w_ih, *w_hh));
  )
}

tensor atg_rnn_tanh_cell(tensor input, tensor hx, tensor w_ih, tensor w_hh) {
  PROTECT(
    return new torch::Tensor(torch::rnn_tanh_cell(*input, *hx, *w_ih, *w_hh));
  )
}

tensor atg_round(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::round(*self));
  )
}

tensor atg_round_(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::round_(*self));
  )
}

tensor atg_round_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::round_out(*result, *self));
  )
}

tensor atg_rrelu(tensor self, int training) {
  PROTECT(
    return new torch::Tensor(torch::rrelu(*self, (bool)training));
  )
}

tensor atg_rrelu_(tensor self, int training) {
  PROTECT(
    return new torch::Tensor(torch::rrelu_(*self, (bool)training));
  )
}

tensor atg_rsqrt(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::rsqrt(*self));
  )
}

tensor atg_rsqrt_(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::rsqrt_(*self));
  )
}

tensor atg_rsqrt_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::rsqrt_out(*result, *self));
  )
}

tensor atg_s_native_addmm(tensor self, tensor mat1, tensor mat2) {
  PROTECT(
    return new torch::Tensor(torch::s_native_addmm(*self, *mat1, *mat2));
  )
}

tensor atg_s_native_addmm_(tensor self, tensor mat1, tensor mat2) {
  PROTECT(
    return new torch::Tensor(torch::s_native_addmm_(*self, *mat1, *mat2));
  )
}

tensor atg_s_native_addmm_out(tensor result, tensor self, tensor mat1, tensor mat2) {
  PROTECT(
    return new torch::Tensor(torch::s_native_addmm_out(*result, *self, *mat1, *mat2));
  )
}

tensor atg_select(tensor self, int64_t dim, int64_t index) {
  PROTECT(
    return new torch::Tensor(torch::select(*self, dim, index));
  )
}

tensor atg_selu(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::selu(*self));
  )
}

tensor atg_selu_(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::selu_(*self));
  )
}

tensor atg_sigmoid(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::sigmoid(*self));
  )
}

tensor atg_sigmoid_(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::sigmoid_(*self));
  )
}

tensor atg_sigmoid_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::sigmoid_out(*result, *self));
  )
}

tensor atg_sin(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::sin(*self));
  )
}

tensor atg_sin_(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::sin_(*self));
  )
}

tensor atg_sin_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::sin_out(*result, *self));
  )
}

tensor atg_sinh(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::sinh(*self));
  )
}

tensor atg_sinh_(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::sinh_(*self));
  )
}

tensor atg_sinh_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::sinh_out(*result, *self));
  )
}

tensor atg_slice(tensor self, int64_t dim, int64_t start, int64_t end, int64_t step) {
  PROTECT(
    return new torch::Tensor(torch::slice(*self, dim, start, end, step));
  )
}

tensor atg_smm(tensor self, tensor mat2) {
  PROTECT(
    return new torch::Tensor(torch::smm(*self, *mat2));
  )
}

tensor atg_softmax(tensor self, int64_t dim) {
  PROTECT(
    return new torch::Tensor(torch::softmax(*self, dim));
  )
}

tensor atg_softmax_backward_data(tensor grad_output, tensor output, int64_t dim, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::softmax_backward_data(*grad_output, *output, dim, *self));
  )
}

tensor atg_sqrt(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::sqrt(*self));
  )
}

tensor atg_sqrt_(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::sqrt_(*self));
  )
}

tensor atg_sqrt_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::sqrt_out(*result, *self));
  )
}

tensor atg_squeeze1(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::squeeze(*self));
  )
}

tensor atg_squeeze2(tensor self, int64_t dim) {
  PROTECT(
    return new torch::Tensor(torch::squeeze(*self, dim));
  )
}

tensor atg_sspaddmm(tensor self, tensor mat1, tensor mat2) {
  PROTECT(
    return new torch::Tensor(torch::sspaddmm(*self, *mat1, *mat2));
  )
}

tensor atg_sspaddmm_out(tensor result, tensor self, tensor mat1, tensor mat2) {
  PROTECT(
    return new torch::Tensor(torch::sspaddmm_out(*result, *self, *mat1, *mat2));
  )
}

tensor atg_std1(tensor self, int unbiased) {
  PROTECT(
    return new torch::Tensor(torch::std(*self, (bool)unbiased));
  )
}

tensor atg_std2(tensor self, int64_t dim, int unbiased, int keepdim) {
  PROTECT(
    return new torch::Tensor(torch::std(*self, dim, (bool)unbiased, (bool)keepdim));
  )
}

tensor atg_std_out(tensor result, tensor self, int64_t dim, int unbiased, int keepdim) {
  PROTECT(
    return new torch::Tensor(torch::std_out(*result, *self, dim, (bool)unbiased, (bool)keepdim));
  )
}

tensor atg_sub(tensor self, tensor other) {
  PROTECT(
    return new torch::Tensor(torch::sub(*self, *other));
  )
}

tensor atg_sub_out(tensor result, tensor self, tensor other) {
  PROTECT(
    return new torch::Tensor(torch::sub_out(*result, *self, *other));
  )
}

tensor atg_sum1(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::sum(*self));
  )
}

tensor atg_sum2(tensor self, int *dim_data, int dim_len, int keepdim) {
  PROTECT(
    return new torch::Tensor(torch::sum(*self, of_carray(dim_data, dim_len), (bool)keepdim));
  )
}

tensor atg_sum_out(tensor result, tensor self, int *dim_data, int dim_len, int keepdim) {
  PROTECT(
    return new torch::Tensor(torch::sum_out(*result, *self, of_carray(dim_data, dim_len), (bool)keepdim));
  )
}

tensor atg_t(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::t(*self));
  )
}

tensor atg_tan(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::tan(*self));
  )
}

tensor atg_tan_(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::tan_(*self));
  )
}

tensor atg_tan_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::tan_out(*result, *self));
  )
}

tensor atg_tanh(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::tanh(*self));
  )
}

tensor atg_tanh_(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::tanh_(*self));
  )
}

tensor atg_tanh_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::tanh_out(*result, *self));
  )
}

tensor atg_tensordot(tensor self, tensor other, int *dims_self_data, int dims_self_len, int *dims_other_data, int dims_other_len) {
  PROTECT(
    return new torch::Tensor(torch::tensordot(*self, *other, of_carray(dims_self_data, dims_self_len), of_carray(dims_other_data, dims_other_len)));
  )
}

tensor atg_transpose(tensor self, int64_t dim0, int64_t dim1) {
  PROTECT(
    return new torch::Tensor(torch::transpose(*self, dim0, dim1));
  )
}

tensor atg_triplet_margin_loss(tensor anchor, tensor positive, tensor negative, double margin, double p, double eps, int swap, int64_t reduction) {
  PROTECT(
    return new torch::Tensor(torch::triplet_margin_loss(*anchor, *positive, *negative, margin, p, eps, (bool)swap, reduction));
  )
}

tensor atg_trunc(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::trunc(*self));
  )
}

tensor atg_trunc_(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::trunc_(*self));
  )
}

tensor atg_trunc_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::trunc_out(*result, *self));
  )
}

tensor atg_unsqueeze(tensor self, int64_t dim) {
  PROTECT(
    return new torch::Tensor(torch::unsqueeze(*self, dim));
  )
}

tensor atg_var1(tensor self, int unbiased) {
  PROTECT(
    return new torch::Tensor(torch::var(*self, (bool)unbiased));
  )
}

tensor atg_var2(tensor self, int64_t dim, int unbiased, int keepdim) {
  PROTECT(
    return new torch::Tensor(torch::var(*self, dim, (bool)unbiased, (bool)keepdim));
  )
}

tensor atg_var_out(tensor result, tensor self, int64_t dim, int unbiased, int keepdim) {
  PROTECT(
    return new torch::Tensor(torch::var_out(*result, *self, dim, (bool)unbiased, (bool)keepdim));
  )
}

tensor atg_zero_(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::zero_(*self));
  )
}

tensor atg_zeros(int *size_data, int size_len) {
  PROTECT(
    return new torch::Tensor(torch::zeros(of_carray(size_data, size_len)));
  )
}

tensor atg_zeros_like(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::zeros_like(*self));
  )
}

tensor atg_zeros_out(tensor result, int *size_data, int size_len) {
  PROTECT(
    return new torch::Tensor(torch::zeros_out(*result, of_carray(size_data, size_len)));
  )
}

