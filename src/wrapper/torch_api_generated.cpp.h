
// THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT BY HAND!

tensor atg_abs(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::abs(*self));
  )
}

tensor atg_abs_(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::abs_(*self));
  )
}

tensor atg_abs_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::abs_out(*result, *self));
  )
}

tensor atg_acos(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::acos(*self));
  )
}

tensor atg_acos_(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::acos_(*self));
  )
}

tensor atg_acos_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::acos_out(*result, *self));
  )
}

tensor atg_adaptive_avg_pool1d(tensor self, int *output_size_data, int output_size_len) {
  PROTECT(
    return new torch::Tensor(torch::adaptive_avg_pool1d(*self, of_carray(output_size_data, output_size_len)));
  )
}

tensor atg_adaptive_avg_pool2d(tensor self, int *output_size_data, int output_size_len) {
  PROTECT(
    return new torch::Tensor(torch::adaptive_avg_pool2d(*self, of_carray(output_size_data, output_size_len)));
  )
}

tensor atg_adaptive_avg_pool2d_backward(tensor grad_output, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::adaptive_avg_pool2d_backward(*grad_output, *self));
  )
}

tensor atg_adaptive_avg_pool2d_backward_out(tensor grad_input, tensor grad_output, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::adaptive_avg_pool2d_backward_out(*grad_input, *grad_output, *self));
  )
}

tensor atg_adaptive_avg_pool2d_forward(tensor self, int *output_size_data, int output_size_len) {
  PROTECT(
    return new torch::Tensor(torch::adaptive_avg_pool2d_forward(*self, of_carray(output_size_data, output_size_len)));
  )
}

tensor atg_adaptive_avg_pool2d_forward_out(tensor output, tensor self, int *output_size_data, int output_size_len) {
  PROTECT(
    return new torch::Tensor(torch::adaptive_avg_pool2d_forward_out(*output, *self, of_carray(output_size_data, output_size_len)));
  )
}

tensor atg_adaptive_avg_pool2d_out(tensor output, tensor self, int *output_size_data, int output_size_len) {
  PROTECT(
    return new torch::Tensor(torch::adaptive_avg_pool2d_out(*output, *self, of_carray(output_size_data, output_size_len)));
  )
}

tensor atg_adaptive_avg_pool3d(tensor self, int *output_size_data, int output_size_len) {
  PROTECT(
    return new torch::Tensor(torch::adaptive_avg_pool3d(*self, of_carray(output_size_data, output_size_len)));
  )
}

tensor atg_adaptive_avg_pool3d_backward(tensor grad_output, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::adaptive_avg_pool3d_backward(*grad_output, *self));
  )
}

tensor atg_adaptive_avg_pool3d_backward_out(tensor grad_input, tensor grad_output, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::adaptive_avg_pool3d_backward_out(*grad_input, *grad_output, *self));
  )
}

tensor atg_adaptive_avg_pool3d_forward(tensor self, int *output_size_data, int output_size_len) {
  PROTECT(
    return new torch::Tensor(torch::adaptive_avg_pool3d_forward(*self, of_carray(output_size_data, output_size_len)));
  )
}

tensor atg_adaptive_avg_pool3d_forward_out(tensor output, tensor self, int *output_size_data, int output_size_len) {
  PROTECT(
    return new torch::Tensor(torch::adaptive_avg_pool3d_forward_out(*output, *self, of_carray(output_size_data, output_size_len)));
  )
}

tensor atg_adaptive_avg_pool3d_out(tensor output, tensor self, int *output_size_data, int output_size_len) {
  PROTECT(
    return new torch::Tensor(torch::adaptive_avg_pool3d_out(*output, *self, of_carray(output_size_data, output_size_len)));
  )
}

tensor atg_add(tensor self, tensor other) {
  PROTECT(
    return new torch::Tensor(torch::add(*self, *other));
  )
}

tensor atg_add_(tensor self, tensor other) {
  PROTECT(
    return new torch::Tensor(self->add_(*other));
  )
}

tensor atg_add_out(tensor result, tensor self, tensor other) {
  PROTECT(
    return new torch::Tensor(torch::add_out(*result, *self, *other));
  )
}

tensor atg_addbmm(tensor self, tensor batch1, tensor batch2) {
  PROTECT(
    return new torch::Tensor(torch::addbmm(*self, *batch1, *batch2));
  )
}

tensor atg_addbmm_(tensor self, tensor batch1, tensor batch2) {
  PROTECT(
    return new torch::Tensor(self->addbmm_(*batch1, *batch2));
  )
}

tensor atg_addbmm_out(tensor result, tensor self, tensor batch1, tensor batch2) {
  PROTECT(
    return new torch::Tensor(torch::addbmm_out(*result, *self, *batch1, *batch2));
  )
}

tensor atg_addcdiv(tensor self, tensor tensor1, tensor tensor2) {
  PROTECT(
    return new torch::Tensor(torch::addcdiv(*self, *tensor1, *tensor2));
  )
}

tensor atg_addcdiv_(tensor self, tensor tensor1, tensor tensor2) {
  PROTECT(
    return new torch::Tensor(self->addcdiv_(*tensor1, *tensor2));
  )
}

tensor atg_addcdiv_out(tensor result, tensor self, tensor tensor1, tensor tensor2) {
  PROTECT(
    return new torch::Tensor(torch::addcdiv_out(*result, *self, *tensor1, *tensor2));
  )
}

tensor atg_addcmul(tensor self, tensor tensor1, tensor tensor2) {
  PROTECT(
    return new torch::Tensor(torch::addcmul(*self, *tensor1, *tensor2));
  )
}

tensor atg_addcmul_(tensor self, tensor tensor1, tensor tensor2) {
  PROTECT(
    return new torch::Tensor(self->addcmul_(*tensor1, *tensor2));
  )
}

tensor atg_addcmul_out(tensor result, tensor self, tensor tensor1, tensor tensor2) {
  PROTECT(
    return new torch::Tensor(torch::addcmul_out(*result, *self, *tensor1, *tensor2));
  )
}

tensor atg_addmm(tensor self, tensor mat1, tensor mat2) {
  PROTECT(
    return new torch::Tensor(torch::addmm(*self, *mat1, *mat2));
  )
}

tensor atg_addmm_(tensor self, tensor mat1, tensor mat2) {
  PROTECT(
    return new torch::Tensor(self->addmm_(*mat1, *mat2));
  )
}

tensor atg_addmm_out(tensor result, tensor self, tensor mat1, tensor mat2) {
  PROTECT(
    return new torch::Tensor(torch::addmm_out(*result, *self, *mat1, *mat2));
  )
}

tensor atg_addmv(tensor self, tensor mat, tensor vec) {
  PROTECT(
    return new torch::Tensor(torch::addmv(*self, *mat, *vec));
  )
}

tensor atg_addmv_(tensor self, tensor mat, tensor vec) {
  PROTECT(
    return new torch::Tensor(torch::addmv_(*self, *mat, *vec));
  )
}

tensor atg_addmv_out(tensor result, tensor self, tensor mat, tensor vec) {
  PROTECT(
    return new torch::Tensor(torch::addmv_out(*result, *self, *mat, *vec));
  )
}

tensor atg_addr(tensor self, tensor vec1, tensor vec2) {
  PROTECT(
    return new torch::Tensor(torch::addr(*self, *vec1, *vec2));
  )
}

tensor atg_addr_(tensor self, tensor vec1, tensor vec2) {
  PROTECT(
    return new torch::Tensor(self->addr_(*vec1, *vec2));
  )
}

tensor atg_addr_out(tensor result, tensor self, tensor vec1, tensor vec2) {
  PROTECT(
    return new torch::Tensor(torch::addr_out(*result, *self, *vec1, *vec2));
  )
}

tensor atg_alias(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::alias(*self));
  )
}

tensor atg_all(tensor self, int64_t dim, int keepdim) {
  PROTECT(
    return new torch::Tensor(torch::all(*self, dim, (bool)keepdim));
  )
}

tensor atg_all_out(tensor result, tensor self, int64_t dim, int keepdim) {
  PROTECT(
    return new torch::Tensor(torch::all_out(*result, *self, dim, (bool)keepdim));
  )
}

tensor atg_alpha_dropout(tensor input, double p, int train) {
  PROTECT(
    return new torch::Tensor(torch::alpha_dropout(*input, p, (bool)train));
  )
}

tensor atg_alpha_dropout_(tensor self, double p, int train) {
  PROTECT(
    return new torch::Tensor(torch::alpha_dropout_(*self, p, (bool)train));
  )
}

tensor atg_any(tensor self, int64_t dim, int keepdim) {
  PROTECT(
    return new torch::Tensor(torch::any(*self, dim, (bool)keepdim));
  )
}

tensor atg_any_out(tensor result, tensor self, int64_t dim, int keepdim) {
  PROTECT(
    return new torch::Tensor(torch::any_out(*result, *self, dim, (bool)keepdim));
  )
}

tensor atg_argmax1(tensor self, int64_t dim, int keepdim) {
  PROTECT(
    return new torch::Tensor(torch::argmax(*self, dim, (bool)keepdim));
  )
}

tensor atg_argmax2(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::argmax(*self));
  )
}

tensor atg_argmin1(tensor self, int64_t dim, int keepdim) {
  PROTECT(
    return new torch::Tensor(torch::argmin(*self, dim, (bool)keepdim));
  )
}

tensor atg_argmin2(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::argmin(*self));
  )
}

tensor atg_as_strided1(tensor self, int *size_data, int size_len, int *stride_data, int stride_len) {
  PROTECT(
    return new torch::Tensor(torch::as_strided(*self, of_carray(size_data, size_len), of_carray(stride_data, stride_len)));
  )
}

tensor atg_as_strided2(tensor self, int *size_data, int size_len, int *stride_data, int stride_len, int64_t storage_offset) {
  PROTECT(
    return new torch::Tensor(torch::as_strided(*self, of_carray(size_data, size_len), of_carray(stride_data, stride_len), storage_offset));
  )
}

tensor atg_as_strided_1(tensor self, int *size_data, int size_len, int *stride_data, int stride_len) {
  PROTECT(
    return new torch::Tensor(torch::as_strided_(*self, of_carray(size_data, size_len), of_carray(stride_data, stride_len)));
  )
}

tensor atg_as_strided_2(tensor self, int *size_data, int size_len, int *stride_data, int stride_len, int64_t storage_offset) {
  PROTECT(
    return new torch::Tensor(torch::as_strided_(*self, of_carray(size_data, size_len), of_carray(stride_data, stride_len), storage_offset));
  )
}

tensor atg_asin(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::asin(*self));
  )
}

tensor atg_asin_(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::asin_(*self));
  )
}

tensor atg_asin_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::asin_out(*result, *self));
  )
}

tensor atg_atan(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::atan(*self));
  )
}

tensor atg_atan2(tensor self, tensor other) {
  PROTECT(
    return new torch::Tensor(torch::atan2(*self, *other));
  )
}

tensor atg_atan2_(tensor self, tensor other) {
  PROTECT(
    return new torch::Tensor(self->atan2_(*other));
  )
}

tensor atg_atan2_out(tensor result, tensor self, tensor other) {
  PROTECT(
    return new torch::Tensor(torch::atan2_out(*result, *self, *other));
  )
}

tensor atg_atan_(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::atan_(*self));
  )
}

tensor atg_atan_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::atan_out(*result, *self));
  )
}

tensor atg_avg_pool1d(tensor self, int *kernel_size_data, int kernel_size_len, int *stride_data, int stride_len, int *padding_data, int padding_len, int ceil_mode, int count_include_pad) {
  PROTECT(
    return new torch::Tensor(torch::avg_pool1d(*self, of_carray(kernel_size_data, kernel_size_len), of_carray(stride_data, stride_len), of_carray(padding_data, padding_len), (bool)ceil_mode, (bool)count_include_pad));
  )
}

tensor atg_avg_pool2d(tensor self, int *kernel_size_data, int kernel_size_len, int *stride_data, int stride_len, int *padding_data, int padding_len, int ceil_mode, int count_include_pad) {
  PROTECT(
    return new torch::Tensor(torch::avg_pool2d(*self, of_carray(kernel_size_data, kernel_size_len), of_carray(stride_data, stride_len), of_carray(padding_data, padding_len), (bool)ceil_mode, (bool)count_include_pad));
  )
}

tensor atg_avg_pool2d_backward(tensor grad_output, tensor self, int *kernel_size_data, int kernel_size_len, int *stride_data, int stride_len, int *padding_data, int padding_len, int ceil_mode, int count_include_pad) {
  PROTECT(
    return new torch::Tensor(torch::avg_pool2d_backward(*grad_output, *self, of_carray(kernel_size_data, kernel_size_len), of_carray(stride_data, stride_len), of_carray(padding_data, padding_len), (bool)ceil_mode, (bool)count_include_pad));
  )
}

tensor atg_avg_pool2d_backward_out(tensor grad_input, tensor grad_output, tensor self, int *kernel_size_data, int kernel_size_len, int *stride_data, int stride_len, int *padding_data, int padding_len, int ceil_mode, int count_include_pad) {
  PROTECT(
    return new torch::Tensor(torch::avg_pool2d_backward_out(*grad_input, *grad_output, *self, of_carray(kernel_size_data, kernel_size_len), of_carray(stride_data, stride_len), of_carray(padding_data, padding_len), (bool)ceil_mode, (bool)count_include_pad));
  )
}

tensor atg_avg_pool2d_forward(tensor self, int *kernel_size_data, int kernel_size_len, int *stride_data, int stride_len, int *padding_data, int padding_len, int ceil_mode, int count_include_pad) {
  PROTECT(
    return new torch::Tensor(torch::avg_pool2d_forward(*self, of_carray(kernel_size_data, kernel_size_len), of_carray(stride_data, stride_len), of_carray(padding_data, padding_len), (bool)ceil_mode, (bool)count_include_pad));
  )
}

tensor atg_avg_pool2d_forward_out(tensor output, tensor self, int *kernel_size_data, int kernel_size_len, int *stride_data, int stride_len, int *padding_data, int padding_len, int ceil_mode, int count_include_pad) {
  PROTECT(
    return new torch::Tensor(torch::avg_pool2d_forward_out(*output, *self, of_carray(kernel_size_data, kernel_size_len), of_carray(stride_data, stride_len), of_carray(padding_data, padding_len), (bool)ceil_mode, (bool)count_include_pad));
  )
}

tensor atg_avg_pool2d_out(tensor output, tensor self, int *kernel_size_data, int kernel_size_len, int *stride_data, int stride_len, int *padding_data, int padding_len, int ceil_mode, int count_include_pad) {
  PROTECT(
    return new torch::Tensor(torch::avg_pool2d_out(*output, *self, of_carray(kernel_size_data, kernel_size_len), of_carray(stride_data, stride_len), of_carray(padding_data, padding_len), (bool)ceil_mode, (bool)count_include_pad));
  )
}

tensor atg_avg_pool3d(tensor self, int *kernel_size_data, int kernel_size_len, int *stride_data, int stride_len, int *padding_data, int padding_len, int ceil_mode, int count_include_pad) {
  PROTECT(
    return new torch::Tensor(torch::avg_pool3d(*self, of_carray(kernel_size_data, kernel_size_len), of_carray(stride_data, stride_len), of_carray(padding_data, padding_len), (bool)ceil_mode, (bool)count_include_pad));
  )
}

tensor atg_avg_pool3d_backward(tensor grad_output, tensor self, int *kernel_size_data, int kernel_size_len, int *stride_data, int stride_len, int *padding_data, int padding_len, int ceil_mode, int count_include_pad) {
  PROTECT(
    return new torch::Tensor(torch::avg_pool3d_backward(*grad_output, *self, of_carray(kernel_size_data, kernel_size_len), of_carray(stride_data, stride_len), of_carray(padding_data, padding_len), (bool)ceil_mode, (bool)count_include_pad));
  )
}

tensor atg_avg_pool3d_backward_out(tensor grad_input, tensor grad_output, tensor self, int *kernel_size_data, int kernel_size_len, int *stride_data, int stride_len, int *padding_data, int padding_len, int ceil_mode, int count_include_pad) {
  PROTECT(
    return new torch::Tensor(torch::avg_pool3d_backward_out(*grad_input, *grad_output, *self, of_carray(kernel_size_data, kernel_size_len), of_carray(stride_data, stride_len), of_carray(padding_data, padding_len), (bool)ceil_mode, (bool)count_include_pad));
  )
}

tensor atg_avg_pool3d_forward(tensor self, int *kernel_size_data, int kernel_size_len, int *stride_data, int stride_len, int *padding_data, int padding_len, int ceil_mode, int count_include_pad) {
  PROTECT(
    return new torch::Tensor(torch::avg_pool3d_forward(*self, of_carray(kernel_size_data, kernel_size_len), of_carray(stride_data, stride_len), of_carray(padding_data, padding_len), (bool)ceil_mode, (bool)count_include_pad));
  )
}

tensor atg_avg_pool3d_forward_out(tensor output, tensor self, int *kernel_size_data, int kernel_size_len, int *stride_data, int stride_len, int *padding_data, int padding_len, int ceil_mode, int count_include_pad) {
  PROTECT(
    return new torch::Tensor(torch::avg_pool3d_forward_out(*output, *self, of_carray(kernel_size_data, kernel_size_len), of_carray(stride_data, stride_len), of_carray(padding_data, padding_len), (bool)ceil_mode, (bool)count_include_pad));
  )
}

tensor atg_avg_pool3d_out(tensor output, tensor self, int *kernel_size_data, int kernel_size_len, int *stride_data, int stride_len, int *padding_data, int padding_len, int ceil_mode, int count_include_pad) {
  PROTECT(
    return new torch::Tensor(torch::avg_pool3d_out(*output, *self, of_carray(kernel_size_data, kernel_size_len), of_carray(stride_data, stride_len), of_carray(padding_data, padding_len), (bool)ceil_mode, (bool)count_include_pad));
  )
}

tensor atg_baddbmm(tensor self, tensor batch1, tensor batch2) {
  PROTECT(
    return new torch::Tensor(torch::baddbmm(*self, *batch1, *batch2));
  )
}

tensor atg_baddbmm_(tensor self, tensor batch1, tensor batch2) {
  PROTECT(
    return new torch::Tensor(self->baddbmm_(*batch1, *batch2));
  )
}

tensor atg_baddbmm_out(tensor result, tensor self, tensor batch1, tensor batch2) {
  PROTECT(
    return new torch::Tensor(torch::baddbmm_out(*result, *self, *batch1, *batch2));
  )
}

tensor atg_bartlett_window1(int64_t window_length, int options) {
  PROTECT(
    return new torch::Tensor(torch::bartlett_window(window_length, torch::ScalarType(options)));
  )
}

tensor atg_bartlett_window2(int64_t window_length, int periodic, int options) {
  PROTECT(
    return new torch::Tensor(torch::bartlett_window(window_length, (bool)periodic, torch::ScalarType(options)));
  )
}

tensor atg_batch_norm(tensor input, tensor weight, tensor bias, tensor running_mean, tensor running_var, int training, double momentum, double eps, int cudnn_enabled) {
  PROTECT(
    return new torch::Tensor(torch::batch_norm(*input, (weight ? *weight : torch::Tensor()), (bias ? *bias : torch::Tensor()), (running_mean ? *running_mean : torch::Tensor()), (running_var ? *running_var : torch::Tensor()), (bool)training, momentum, eps, (bool)cudnn_enabled));
  )
}

tensor atg_bernoulli1(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::bernoulli(*self));
  )
}

tensor atg_bernoulli2(tensor self, double p) {
  PROTECT(
    return new torch::Tensor(torch::bernoulli(*self, p));
  )
}

tensor atg_bernoulli_1(tensor self, tensor p) {
  PROTECT(
    return new torch::Tensor(self->bernoulli_(*p));
  )
}

tensor atg_bernoulli_2(tensor self, double p) {
  PROTECT(
    return new torch::Tensor(self->bernoulli_(p));
  )
}

tensor atg_bernoulli_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::bernoulli_out(*result, *self));
  )
}

tensor atg_bilinear(tensor input1, tensor input2, tensor weight, tensor bias) {
  PROTECT(
    return new torch::Tensor(torch::bilinear(*input1, *input2, *weight, (bias ? *bias : torch::Tensor())));
  )
}

tensor atg_binary_cross_entropy(tensor self, tensor target, tensor weight, int64_t reduction) {
  PROTECT(
    return new torch::Tensor(torch::binary_cross_entropy(*self, *target, *weight, reduction));
  )
}

tensor atg_binary_cross_entropy_backward(tensor grad_output, tensor self, tensor target, tensor weight, int64_t reduction) {
  PROTECT(
    return new torch::Tensor(torch::binary_cross_entropy_backward(*grad_output, *self, *target, (weight ? *weight : torch::Tensor()), reduction));
  )
}

tensor atg_binary_cross_entropy_backward_out(tensor grad_input, tensor grad_output, tensor self, tensor target, tensor weight, int64_t reduction) {
  PROTECT(
    return new torch::Tensor(torch::binary_cross_entropy_backward_out(*grad_input, *grad_output, *self, *target, (weight ? *weight : torch::Tensor()), reduction));
  )
}

tensor atg_binary_cross_entropy_forward(tensor self, tensor target, tensor weight, int64_t reduction) {
  PROTECT(
    return new torch::Tensor(torch::binary_cross_entropy_forward(*self, *target, (weight ? *weight : torch::Tensor()), reduction));
  )
}

tensor atg_binary_cross_entropy_forward_out(tensor output, tensor self, tensor target, tensor weight, int64_t reduction) {
  PROTECT(
    return new torch::Tensor(torch::binary_cross_entropy_forward_out(*output, *self, *target, (weight ? *weight : torch::Tensor()), reduction));
  )
}

tensor atg_binary_cross_entropy_out(tensor output, tensor self, tensor target, tensor weight, int64_t reduction) {
  PROTECT(
    return new torch::Tensor(torch::binary_cross_entropy_out(*output, *self, *target, *weight, reduction));
  )
}

tensor atg_blackman_window1(int64_t window_length, int options) {
  PROTECT(
    return new torch::Tensor(torch::blackman_window(window_length, torch::ScalarType(options)));
  )
}

tensor atg_blackman_window2(int64_t window_length, int periodic, int options) {
  PROTECT(
    return new torch::Tensor(torch::blackman_window(window_length, (bool)periodic, torch::ScalarType(options)));
  )
}

tensor atg_bmm(tensor self, tensor mat2) {
  PROTECT(
    return new torch::Tensor(torch::bmm(*self, *mat2));
  )
}

tensor atg_bmm_out(tensor result, tensor self, tensor mat2) {
  PROTECT(
    return new torch::Tensor(torch::bmm_out(*result, *self, *mat2));
  )
}

tensor atg_cauchy_(tensor self, double median, double sigma) {
  PROTECT(
    return new torch::Tensor(self->cauchy_(median, sigma));
  )
}

tensor atg_ceil(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::ceil(*self));
  )
}

tensor atg_ceil_(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::ceil_(*self));
  )
}

tensor atg_ceil_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::ceil_out(*result, *self));
  )
}

tensor atg_celu(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::celu(*self));
  )
}

tensor atg_celu_(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::celu_(*self));
  )
}

tensor atg_clone(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::clone(*self));
  )
}

tensor atg_coalesce(tensor self) {
  PROTECT(
    return new torch::Tensor(self->coalesce());
  )
}

tensor atg_contiguous(tensor self) {
  PROTECT(
    return new torch::Tensor(self->contiguous());
  )
}

tensor atg_conv1d(tensor input, tensor weight, tensor bias, int *stride_data, int stride_len, int *padding_data, int padding_len, int *dilation_data, int dilation_len, int64_t groups) {
  PROTECT(
    return new torch::Tensor(torch::conv1d(*input, *weight, *bias, of_carray(stride_data, stride_len), of_carray(padding_data, padding_len), of_carray(dilation_data, dilation_len), groups));
  )
}

tensor atg_conv2d(tensor input, tensor weight, tensor bias, int *stride_data, int stride_len, int *padding_data, int padding_len, int *dilation_data, int dilation_len, int64_t groups) {
  PROTECT(
    return new torch::Tensor(torch::conv2d(*input, *weight, *bias, of_carray(stride_data, stride_len), of_carray(padding_data, padding_len), of_carray(dilation_data, dilation_len), groups));
  )
}

tensor atg_conv3d(tensor input, tensor weight, tensor bias, int *stride_data, int stride_len, int *padding_data, int padding_len, int *dilation_data, int dilation_len, int64_t groups) {
  PROTECT(
    return new torch::Tensor(torch::conv3d(*input, *weight, *bias, of_carray(stride_data, stride_len), of_carray(padding_data, padding_len), of_carray(dilation_data, dilation_len), groups));
  )
}

tensor atg_conv_tbc(tensor self, tensor weight, tensor bias, int64_t pad) {
  PROTECT(
    return new torch::Tensor(torch::conv_tbc(*self, *weight, *bias, pad));
  )
}

tensor atg_conv_transpose1d(tensor input, tensor weight, tensor bias, int *stride_data, int stride_len, int *padding_data, int padding_len, int *output_padding_data, int output_padding_len, int64_t groups, int *dilation_data, int dilation_len) {
  PROTECT(
    return new torch::Tensor(torch::conv_transpose1d(*input, *weight, *bias, of_carray(stride_data, stride_len), of_carray(padding_data, padding_len), of_carray(output_padding_data, output_padding_len), groups, of_carray(dilation_data, dilation_len)));
  )
}

tensor atg_conv_transpose2d(tensor input, tensor weight, tensor bias, int *stride_data, int stride_len, int *padding_data, int padding_len, int *output_padding_data, int output_padding_len, int64_t groups, int *dilation_data, int dilation_len) {
  PROTECT(
    return new torch::Tensor(torch::conv_transpose2d(*input, *weight, *bias, of_carray(stride_data, stride_len), of_carray(padding_data, padding_len), of_carray(output_padding_data, output_padding_len), groups, of_carray(dilation_data, dilation_len)));
  )
}

tensor atg_conv_transpose3d(tensor input, tensor weight, tensor bias, int *stride_data, int stride_len, int *padding_data, int padding_len, int *output_padding_data, int output_padding_len, int64_t groups, int *dilation_data, int dilation_len) {
  PROTECT(
    return new torch::Tensor(torch::conv_transpose3d(*input, *weight, *bias, of_carray(stride_data, stride_len), of_carray(padding_data, padding_len), of_carray(output_padding_data, output_padding_len), groups, of_carray(dilation_data, dilation_len)));
  )
}

tensor atg_convolution(tensor input, tensor weight, tensor bias, int *stride_data, int stride_len, int *padding_data, int padding_len, int *dilation_data, int dilation_len, int transposed, int *output_padding_data, int output_padding_len, int64_t groups) {
  PROTECT(
    return new torch::Tensor(torch::convolution(*input, *weight, (bias ? *bias : torch::Tensor()), of_carray(stride_data, stride_len), of_carray(padding_data, padding_len), of_carray(dilation_data, dilation_len), (bool)transposed, of_carray(output_padding_data, output_padding_len), groups));
  )
}

tensor atg_copy_sparse_to_sparse_(tensor self, tensor src, int non_blocking) {
  PROTECT(
    return new torch::Tensor(torch::copy_sparse_to_sparse_(*self, *src, (bool)non_blocking));
  )
}

tensor atg_cos(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::cos(*self));
  )
}

tensor atg_cos_(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::cos_(*self));
  )
}

tensor atg_cos_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::cos_out(*result, *self));
  )
}

tensor atg_cosh(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::cosh(*self));
  )
}

tensor atg_cosh_(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::cosh_(*self));
  )
}

tensor atg_cosh_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::cosh_out(*result, *self));
  )
}

tensor atg_cosine_embedding_loss(tensor input1, tensor input2, tensor target, double margin, int64_t reduction) {
  PROTECT(
    return new torch::Tensor(torch::cosine_embedding_loss(*input1, *input2, *target, margin, reduction));
  )
}

tensor atg_cross(tensor self, tensor other, int64_t dim) {
  PROTECT(
    return new torch::Tensor(torch::cross(*self, *other, dim));
  )
}

tensor atg_cross_out(tensor result, tensor self, tensor other, int64_t dim) {
  PROTECT(
    return new torch::Tensor(torch::cross_out(*result, *self, *other, dim));
  )
}

tensor atg_ctc_loss1(tensor log_probs, tensor targets, int *input_lengths_data, int input_lengths_len, int *target_lengths_data, int target_lengths_len, int64_t blank, int64_t reduction) {
  PROTECT(
    return new torch::Tensor(torch::ctc_loss(*log_probs, *targets, of_carray(input_lengths_data, input_lengths_len), of_carray(target_lengths_data, target_lengths_len), blank, reduction));
  )
}

tensor atg_ctc_loss2(tensor log_probs, tensor targets, tensor input_lengths, tensor target_lengths, int64_t blank, int64_t reduction) {
  PROTECT(
    return new torch::Tensor(torch::ctc_loss(*log_probs, *targets, *input_lengths, *target_lengths, blank, reduction));
  )
}

tensor atg_cudnn_affine_grid_generator(tensor theta, int64_t N, int64_t C, int64_t H, int64_t W) {
  PROTECT(
    return new torch::Tensor(torch::cudnn_affine_grid_generator(*theta, N, C, H, W));
  )
}

tensor atg_cudnn_affine_grid_generator_backward(tensor grad, int64_t N, int64_t C, int64_t H, int64_t W) {
  PROTECT(
    return new torch::Tensor(torch::cudnn_affine_grid_generator_backward(*grad, N, C, H, W));
  )
}

tensor atg_cudnn_convolution(tensor self, tensor weight, tensor bias, int *padding_data, int padding_len, int *stride_data, int stride_len, int *dilation_data, int dilation_len, int64_t groups, int benchmark, int deterministic) {
  PROTECT(
    return new torch::Tensor(torch::cudnn_convolution(*self, *weight, (bias ? *bias : torch::Tensor()), of_carray(padding_data, padding_len), of_carray(stride_data, stride_len), of_carray(dilation_data, dilation_len), groups, (bool)benchmark, (bool)deterministic));
  )
}

tensor atg_cudnn_convolution_backward_bias(tensor grad_output) {
  PROTECT(
    return new torch::Tensor(torch::cudnn_convolution_backward_bias(*grad_output));
  )
}

tensor atg_cudnn_convolution_backward_input(int *self_size_data, int self_size_len, tensor grad_output, tensor weight, int *padding_data, int padding_len, int *stride_data, int stride_len, int *dilation_data, int dilation_len, int64_t groups, int benchmark, int deterministic) {
  PROTECT(
    return new torch::Tensor(torch::cudnn_convolution_backward_input(of_carray(self_size_data, self_size_len), *grad_output, *weight, of_carray(padding_data, padding_len), of_carray(stride_data, stride_len), of_carray(dilation_data, dilation_len), groups, (bool)benchmark, (bool)deterministic));
  )
}

tensor atg_cudnn_convolution_backward_weight(int *weight_size_data, int weight_size_len, tensor grad_output, tensor self, int *padding_data, int padding_len, int *stride_data, int stride_len, int *dilation_data, int dilation_len, int64_t groups, int benchmark, int deterministic) {
  PROTECT(
    return new torch::Tensor(torch::cudnn_convolution_backward_weight(of_carray(weight_size_data, weight_size_len), *grad_output, *self, of_carray(padding_data, padding_len), of_carray(stride_data, stride_len), of_carray(dilation_data, dilation_len), groups, (bool)benchmark, (bool)deterministic));
  )
}

tensor atg_cudnn_convolution_transpose(tensor self, tensor weight, tensor bias, int *padding_data, int padding_len, int *output_padding_data, int output_padding_len, int *stride_data, int stride_len, int *dilation_data, int dilation_len, int64_t groups, int benchmark, int deterministic) {
  PROTECT(
    return new torch::Tensor(torch::cudnn_convolution_transpose(*self, *weight, (bias ? *bias : torch::Tensor()), of_carray(padding_data, padding_len), of_carray(output_padding_data, output_padding_len), of_carray(stride_data, stride_len), of_carray(dilation_data, dilation_len), groups, (bool)benchmark, (bool)deterministic));
  )
}

tensor atg_cudnn_convolution_transpose_backward_bias(tensor grad_output) {
  PROTECT(
    return new torch::Tensor(torch::cudnn_convolution_transpose_backward_bias(*grad_output));
  )
}

tensor atg_cudnn_convolution_transpose_backward_input(tensor grad_output, tensor weight, int *padding_data, int padding_len, int *stride_data, int stride_len, int *dilation_data, int dilation_len, int64_t groups, int benchmark, int deterministic) {
  PROTECT(
    return new torch::Tensor(torch::cudnn_convolution_transpose_backward_input(*grad_output, *weight, of_carray(padding_data, padding_len), of_carray(stride_data, stride_len), of_carray(dilation_data, dilation_len), groups, (bool)benchmark, (bool)deterministic));
  )
}

tensor atg_cudnn_convolution_transpose_backward_weight(int *weight_size_data, int weight_size_len, tensor grad_output, tensor self, int *padding_data, int padding_len, int *stride_data, int stride_len, int *dilation_data, int dilation_len, int64_t groups, int benchmark, int deterministic) {
  PROTECT(
    return new torch::Tensor(torch::cudnn_convolution_transpose_backward_weight(of_carray(weight_size_data, weight_size_len), *grad_output, *self, of_carray(padding_data, padding_len), of_carray(stride_data, stride_len), of_carray(dilation_data, dilation_len), groups, (bool)benchmark, (bool)deterministic));
  )
}

tensor atg_cudnn_grid_sampler(tensor self, tensor grid) {
  PROTECT(
    return new torch::Tensor(torch::cudnn_grid_sampler(*self, *grid));
  )
}

tensor atg_cumprod1(tensor self, int64_t dim, int dtype) {
  PROTECT(
    return new torch::Tensor(torch::cumprod(*self, dim, torch::ScalarType(dtype)));
  )
}

tensor atg_cumprod2(tensor self, int64_t dim) {
  PROTECT(
    return new torch::Tensor(torch::cumprod(*self, dim));
  )
}

tensor atg_cumprod_out1(tensor result, tensor self, int64_t dim, int dtype) {
  PROTECT(
    return new torch::Tensor(torch::cumprod_out(*result, *self, dim, torch::ScalarType(dtype)));
  )
}

tensor atg_cumprod_out2(tensor result, tensor self, int64_t dim) {
  PROTECT(
    return new torch::Tensor(torch::cumprod_out(*result, *self, dim));
  )
}

tensor atg_cumsum1(tensor self, int64_t dim, int dtype) {
  PROTECT(
    return new torch::Tensor(torch::cumsum(*self, dim, torch::ScalarType(dtype)));
  )
}

tensor atg_cumsum2(tensor self, int64_t dim) {
  PROTECT(
    return new torch::Tensor(torch::cumsum(*self, dim));
  )
}

tensor atg_cumsum_out1(tensor result, tensor self, int64_t dim, int dtype) {
  PROTECT(
    return new torch::Tensor(torch::cumsum_out(*result, *self, dim, torch::ScalarType(dtype)));
  )
}

tensor atg_cumsum_out2(tensor result, tensor self, int64_t dim) {
  PROTECT(
    return new torch::Tensor(torch::cumsum_out(*result, *self, dim));
  )
}

tensor atg_det(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::det(*self));
  )
}

tensor atg_detach(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::detach(*self));
  )
}

tensor atg_detach_(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::detach_(*self));
  )
}

tensor atg_diag(tensor self, int64_t diagonal) {
  PROTECT(
    return new torch::Tensor(torch::diag(*self, diagonal));
  )
}

tensor atg_diag_out(tensor result, tensor self, int64_t diagonal) {
  PROTECT(
    return new torch::Tensor(torch::diag_out(*result, *self, diagonal));
  )
}

tensor atg_diagflat(tensor self, int64_t offset) {
  PROTECT(
    return new torch::Tensor(torch::diagflat(*self, offset));
  )
}

tensor atg_diagonal(tensor self, int64_t offset, int64_t dim1, int64_t dim2) {
  PROTECT(
    return new torch::Tensor(torch::diagonal(*self, offset, dim1, dim2));
  )
}

tensor atg_digamma(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::digamma(*self));
  )
}

tensor atg_digamma_(tensor self) {
  PROTECT(
    return new torch::Tensor(self->digamma_());
  )
}

tensor atg_digamma_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::digamma_out(*result, *self));
  )
}

tensor atg_div(tensor self, tensor other) {
  PROTECT(
    return new torch::Tensor(torch::div(*self, *other));
  )
}

tensor atg_div_(tensor self, tensor other) {
  PROTECT(
    return new torch::Tensor(self->div_(*other));
  )
}

tensor atg_div_out(tensor result, tensor self, tensor other) {
  PROTECT(
    return new torch::Tensor(torch::div_out(*result, *self, *other));
  )
}

tensor atg_dot(tensor self, tensor tensor) {
  PROTECT(
    return new torch::Tensor(torch::dot(*self, *tensor));
  )
}

tensor atg_dot_out(tensor result, tensor self, tensor tensor) {
  PROTECT(
    return new torch::Tensor(torch::dot_out(*result, *self, *tensor));
  )
}

tensor atg_dropout(tensor input, double p, int train) {
  PROTECT(
    return new torch::Tensor(torch::dropout(*input, p, (bool)train));
  )
}

tensor atg_dropout_(tensor self, double p, int train) {
  PROTECT(
    return new torch::Tensor(torch::dropout_(*self, p, (bool)train));
  )
}

tensor atg_elu(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::elu(*self));
  )
}

tensor atg_elu_(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::elu_(*self));
  )
}

tensor atg_elu_out(tensor output, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::elu_out(*output, *self));
  )
}

tensor atg_empty(int *size_data, int size_len, int options) {
  PROTECT(
    return new torch::Tensor(torch::empty(of_carray(size_data, size_len), torch::ScalarType(options)));
  )
}

tensor atg_empty_like1(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::empty_like(*self));
  )
}

tensor atg_empty_like2(tensor self, int options) {
  PROTECT(
    return new torch::Tensor(torch::empty_like(*self, torch::ScalarType(options)));
  )
}

tensor atg_empty_out(tensor result, int *size_data, int size_len) {
  PROTECT(
    return new torch::Tensor(torch::empty_out(*result, of_carray(size_data, size_len)));
  )
}

tensor atg_empty_strided(int *size_data, int size_len, int *stride_data, int stride_len, int options) {
  PROTECT(
    return new torch::Tensor(torch::empty_strided(of_carray(size_data, size_len), of_carray(stride_data, stride_len), torch::ScalarType(options)));
  )
}

tensor atg_eq(tensor self, tensor other) {
  PROTECT(
    return new torch::Tensor(torch::eq(*self, *other));
  )
}

tensor atg_eq_(tensor self, tensor other) {
  PROTECT(
    return new torch::Tensor(self->eq_(*other));
  )
}

tensor atg_erf(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::erf(*self));
  )
}

tensor atg_erf_(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::erf_(*self));
  )
}

tensor atg_erf_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::erf_out(*result, *self));
  )
}

tensor atg_erfc(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::erfc(*self));
  )
}

tensor atg_erfc_(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::erfc_(*self));
  )
}

tensor atg_erfc_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::erfc_out(*result, *self));
  )
}

tensor atg_erfinv(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::erfinv(*self));
  )
}

tensor atg_erfinv_(tensor self) {
  PROTECT(
    return new torch::Tensor(self->erfinv_());
  )
}

tensor atg_erfinv_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::erfinv_out(*result, *self));
  )
}

tensor atg_exp(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::exp(*self));
  )
}

tensor atg_exp_(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::exp_(*self));
  )
}

tensor atg_exp_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::exp_out(*result, *self));
  )
}

tensor atg_expand(tensor self, int *size_data, int size_len, int implicit) {
  PROTECT(
    return new torch::Tensor(self->expand(of_carray(size_data, size_len), (bool)implicit));
  )
}

tensor atg_expand_as(tensor self, tensor other) {
  PROTECT(
    return new torch::Tensor(self->expand_as(*other));
  )
}

tensor atg_expm1(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::expm1(*self));
  )
}

tensor atg_expm1_(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::expm1_(*self));
  )
}

tensor atg_expm1_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::expm1_out(*result, *self));
  )
}

tensor atg_exponential_(tensor self, double lambd) {
  PROTECT(
    return new torch::Tensor(self->exponential_(lambd));
  )
}

tensor atg_eye1(int64_t n, int options) {
  PROTECT(
    return new torch::Tensor(torch::eye(n, torch::ScalarType(options)));
  )
}

tensor atg_eye2(int64_t n, int64_t m, int options) {
  PROTECT(
    return new torch::Tensor(torch::eye(n, m, torch::ScalarType(options)));
  )
}

tensor atg_eye_out1(tensor result, int64_t n) {
  PROTECT(
    return new torch::Tensor(torch::eye_out(*result, n));
  )
}

tensor atg_eye_out2(tensor result, int64_t n, int64_t m) {
  PROTECT(
    return new torch::Tensor(torch::eye_out(*result, n, m));
  )
}

tensor atg_feature_alpha_dropout(tensor input, double p, int train) {
  PROTECT(
    return new torch::Tensor(torch::feature_alpha_dropout(*input, p, (bool)train));
  )
}

tensor atg_feature_alpha_dropout_(tensor self, double p, int train) {
  PROTECT(
    return new torch::Tensor(torch::feature_alpha_dropout_(*self, p, (bool)train));
  )
}

tensor atg_feature_dropout(tensor input, double p, int train) {
  PROTECT(
    return new torch::Tensor(torch::feature_dropout(*input, p, (bool)train));
  )
}

tensor atg_feature_dropout_(tensor self, double p, int train) {
  PROTECT(
    return new torch::Tensor(torch::feature_dropout_(*self, p, (bool)train));
  )
}

tensor atg_fft(tensor self, int64_t signal_ndim, int normalized) {
  PROTECT(
    return new torch::Tensor(torch::fft(*self, signal_ndim, (bool)normalized));
  )
}

tensor atg_fill_(tensor self, tensor value) {
  PROTECT(
    return new torch::Tensor(torch::fill_(*self, *value));
  )
}

tensor atg_flatten(tensor self, int64_t start_dim, int64_t end_dim) {
  PROTECT(
    return new torch::Tensor(torch::flatten(*self, start_dim, end_dim));
  )
}

tensor atg_flip(tensor self, int *dims_data, int dims_len) {
  PROTECT(
    return new torch::Tensor(torch::flip(*self, of_carray(dims_data, dims_len)));
  )
}

tensor atg_floor(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::floor(*self));
  )
}

tensor atg_floor_(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::floor_(*self));
  )
}

tensor atg_floor_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::floor_out(*result, *self));
  )
}

tensor atg_fmod(tensor self, tensor other) {
  PROTECT(
    return new torch::Tensor(torch::fmod(*self, *other));
  )
}

tensor atg_fmod_(tensor self, tensor other) {
  PROTECT(
    return new torch::Tensor(self->fmod_(*other));
  )
}

tensor atg_fmod_out(tensor result, tensor self, tensor other) {
  PROTECT(
    return new torch::Tensor(torch::fmod_out(*result, *self, *other));
  )
}

tensor atg_frac(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::frac(*self));
  )
}

tensor atg_frac_(tensor self) {
  PROTECT(
    return new torch::Tensor(self->frac_());
  )
}

tensor atg_frac_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::frac_out(*result, *self));
  )
}

tensor atg_frobenius_norm1(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::frobenius_norm(*self));
  )
}

tensor atg_frobenius_norm2(tensor self, int *dim_data, int dim_len, int keepdim) {
  PROTECT(
    return new torch::Tensor(torch::frobenius_norm(*self, of_carray(dim_data, dim_len), (bool)keepdim));
  )
}

tensor atg_frobenius_norm_out(tensor result, tensor self, int *dim_data, int dim_len, int keepdim) {
  PROTECT(
    return new torch::Tensor(torch::frobenius_norm_out(*result, *self, of_carray(dim_data, dim_len), (bool)keepdim));
  )
}

tensor atg_ge(tensor self, tensor other) {
  PROTECT(
    return new torch::Tensor(torch::ge(*self, *other));
  )
}

tensor atg_ge_(tensor self, tensor other) {
  PROTECT(
    return new torch::Tensor(self->ge_(*other));
  )
}

tensor atg_geometric_(tensor self, double p) {
  PROTECT(
    return new torch::Tensor(self->geometric_(p));
  )
}

tensor atg_ger(tensor self, tensor vec2) {
  PROTECT(
    return new torch::Tensor(torch::ger(*self, *vec2));
  )
}

tensor atg_ger_out(tensor result, tensor self, tensor vec2) {
  PROTECT(
    return new torch::Tensor(torch::ger_out(*result, *self, *vec2));
  )
}

tensor atg_glu(tensor self, int64_t dim) {
  PROTECT(
    return new torch::Tensor(torch::glu(*self, dim));
  )
}

tensor atg_glu_backward(tensor grad_output, tensor self, int64_t dim) {
  PROTECT(
    return new torch::Tensor(torch::glu_backward(*grad_output, *self, dim));
  )
}

tensor atg_glu_backward_out(tensor grad_input, tensor grad_output, tensor self, int64_t dim) {
  PROTECT(
    return new torch::Tensor(torch::glu_backward_out(*grad_input, *grad_output, *self, dim));
  )
}

tensor atg_glu_forward(tensor self, int64_t dim) {
  PROTECT(
    return new torch::Tensor(torch::glu_forward(*self, dim));
  )
}

tensor atg_glu_forward_out(tensor output, tensor self, int64_t dim) {
  PROTECT(
    return new torch::Tensor(torch::glu_forward_out(*output, *self, dim));
  )
}

tensor atg_glu_out(tensor output, tensor self, int64_t dim) {
  PROTECT(
    return new torch::Tensor(torch::glu_out(*output, *self, dim));
  )
}

tensor atg_grad(tensor self) {
  PROTECT(
    return new torch::Tensor(self->grad());
  )
}

tensor atg_grid_sampler(tensor input, tensor grid, int64_t interpolation_mode, int64_t padding_mode) {
  PROTECT(
    return new torch::Tensor(torch::grid_sampler(*input, *grid, interpolation_mode, padding_mode));
  )
}

tensor atg_grid_sampler_2d(tensor input, tensor grid, int64_t interpolation_mode, int64_t padding_mode) {
  PROTECT(
    return new torch::Tensor(torch::grid_sampler_2d(*input, *grid, interpolation_mode, padding_mode));
  )
}

tensor atg_grid_sampler_3d(tensor input, tensor grid, int64_t interpolation_mode, int64_t padding_mode) {
  PROTECT(
    return new torch::Tensor(torch::grid_sampler_3d(*input, *grid, interpolation_mode, padding_mode));
  )
}

tensor atg_gru_cell(tensor input, tensor hx, tensor w_ih, tensor w_hh, tensor b_ih, tensor b_hh) {
  PROTECT(
    return new torch::Tensor(torch::gru_cell(*input, *hx, *w_ih, *w_hh, (b_ih ? *b_ih : torch::Tensor()), (b_hh ? *b_hh : torch::Tensor())));
  )
}

tensor atg_gt(tensor self, tensor other) {
  PROTECT(
    return new torch::Tensor(torch::gt(*self, *other));
  )
}

tensor atg_gt_(tensor self, tensor other) {
  PROTECT(
    return new torch::Tensor(self->gt_(*other));
  )
}

tensor atg_hamming_window1(int64_t window_length, int options) {
  PROTECT(
    return new torch::Tensor(torch::hamming_window(window_length, torch::ScalarType(options)));
  )
}

tensor atg_hamming_window2(int64_t window_length, int periodic, int options) {
  PROTECT(
    return new torch::Tensor(torch::hamming_window(window_length, (bool)periodic, torch::ScalarType(options)));
  )
}

tensor atg_hamming_window3(int64_t window_length, int periodic, double alpha, int options) {
  PROTECT(
    return new torch::Tensor(torch::hamming_window(window_length, (bool)periodic, alpha, torch::ScalarType(options)));
  )
}

tensor atg_hamming_window4(int64_t window_length, int periodic, double alpha, double beta, int options) {
  PROTECT(
    return new torch::Tensor(torch::hamming_window(window_length, (bool)periodic, alpha, beta, torch::ScalarType(options)));
  )
}

tensor atg_hann_window1(int64_t window_length, int options) {
  PROTECT(
    return new torch::Tensor(torch::hann_window(window_length, torch::ScalarType(options)));
  )
}

tensor atg_hann_window2(int64_t window_length, int periodic, int options) {
  PROTECT(
    return new torch::Tensor(torch::hann_window(window_length, (bool)periodic, torch::ScalarType(options)));
  )
}

tensor atg_hardshrink(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::hardshrink(*self));
  )
}

tensor atg_hardtanh(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::hardtanh(*self));
  )
}

tensor atg_hardtanh_(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::hardtanh_(*self));
  )
}

tensor atg_hardtanh_out(tensor output, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::hardtanh_out(*output, *self));
  )
}

tensor atg_hinge_embedding_loss(tensor self, tensor target, double margin, int64_t reduction) {
  PROTECT(
    return new torch::Tensor(torch::hinge_embedding_loss(*self, *target, margin, reduction));
  )
}

tensor atg_histc(tensor self, int64_t bins) {
  PROTECT(
    return new torch::Tensor(torch::histc(*self, bins));
  )
}

tensor atg_histc_out(tensor result, tensor self, int64_t bins) {
  PROTECT(
    return new torch::Tensor(torch::histc_out(*result, *self, bins));
  )
}

tensor atg_hspmm(tensor mat1, tensor mat2) {
  PROTECT(
    return new torch::Tensor(torch::hspmm(*mat1, *mat2));
  )
}

tensor atg_hspmm_out(tensor result, tensor mat1, tensor mat2) {
  PROTECT(
    return new torch::Tensor(torch::hspmm_out(*result, *mat1, *mat2));
  )
}

tensor atg_ifft(tensor self, int64_t signal_ndim, int normalized) {
  PROTECT(
    return new torch::Tensor(torch::ifft(*self, signal_ndim, (bool)normalized));
  )
}

tensor atg_instance_norm(tensor input, tensor weight, tensor bias, tensor running_mean, tensor running_var, int use_input_stats, double momentum, double eps, int cudnn_enabled) {
  PROTECT(
    return new torch::Tensor(torch::instance_norm(*input, (weight ? *weight : torch::Tensor()), (bias ? *bias : torch::Tensor()), (running_mean ? *running_mean : torch::Tensor()), (running_var ? *running_var : torch::Tensor()), (bool)use_input_stats, momentum, eps, (bool)cudnn_enabled));
  )
}

tensor atg_inverse(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::inverse(*self));
  )
}

tensor atg_inverse_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::inverse_out(*result, *self));
  )
}

tensor atg_irfft(tensor self, int64_t signal_ndim, int normalized, int onesided, int *signal_sizes_data, int signal_sizes_len) {
  PROTECT(
    return new torch::Tensor(torch::irfft(*self, signal_ndim, (bool)normalized, (bool)onesided, of_carray(signal_sizes_data, signal_sizes_len)));
  )
}

tensor atg_isclose(tensor self, tensor other, double rtol, double atol, int equal_nan) {
  PROTECT(
    return new torch::Tensor(torch::isclose(*self, *other, rtol, atol, (bool)equal_nan));
  )
}

tensor atg_kl_div(tensor self, tensor target, int64_t reduction) {
  PROTECT(
    return new torch::Tensor(torch::kl_div(*self, *target, reduction));
  )
}

tensor atg_kl_div_backward(tensor grad_output, tensor self, tensor target, int64_t reduction) {
  PROTECT(
    return new torch::Tensor(torch::kl_div_backward(*grad_output, *self, *target, reduction));
  )
}

tensor atg_l1_loss(tensor self, tensor target, int64_t reduction) {
  PROTECT(
    return new torch::Tensor(torch::l1_loss(*self, *target, reduction));
  )
}

tensor atg_l1_loss_backward(tensor grad_output, tensor self, tensor target, int64_t reduction) {
  PROTECT(
    return new torch::Tensor(torch::l1_loss_backward(*grad_output, *self, *target, reduction));
  )
}

tensor atg_l1_loss_backward_out(tensor grad_input, tensor grad_output, tensor self, tensor target, int64_t reduction) {
  PROTECT(
    return new torch::Tensor(torch::l1_loss_backward_out(*grad_input, *grad_output, *self, *target, reduction));
  )
}

tensor atg_l1_loss_forward(tensor self, tensor target, int64_t reduction) {
  PROTECT(
    return new torch::Tensor(torch::l1_loss_forward(*self, *target, reduction));
  )
}

tensor atg_l1_loss_forward_out(tensor output, tensor self, tensor target, int64_t reduction) {
  PROTECT(
    return new torch::Tensor(torch::l1_loss_forward_out(*output, *self, *target, reduction));
  )
}

tensor atg_l1_loss_out(tensor output, tensor self, tensor target, int64_t reduction) {
  PROTECT(
    return new torch::Tensor(torch::l1_loss_out(*output, *self, *target, reduction));
  )
}

tensor atg_le(tensor self, tensor other) {
  PROTECT(
    return new torch::Tensor(torch::le(*self, *other));
  )
}

tensor atg_le_(tensor self, tensor other) {
  PROTECT(
    return new torch::Tensor(self->le_(*other));
  )
}

tensor atg_leaky_relu(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::leaky_relu(*self));
  )
}

tensor atg_leaky_relu_(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::leaky_relu_(*self));
  )
}

tensor atg_leaky_relu_out(tensor output, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::leaky_relu_out(*output, *self));
  )
}

tensor atg_lgamma(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::lgamma(*self));
  )
}

tensor atg_lgamma_(tensor self) {
  PROTECT(
    return new torch::Tensor(self->lgamma_());
  )
}

tensor atg_lgamma_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::lgamma_out(*result, *self));
  )
}

tensor atg_linear(tensor input, tensor weight, tensor bias) {
  PROTECT(
    return new torch::Tensor(torch::linear(*input, *weight, *bias));
  )
}

tensor atg_log(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::log(*self));
  )
}

tensor atg_log10(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::log10(*self));
  )
}

tensor atg_log10_(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::log10_(*self));
  )
}

tensor atg_log10_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::log10_out(*result, *self));
  )
}

tensor atg_log1p(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::log1p(*self));
  )
}

tensor atg_log1p_(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::log1p_(*self));
  )
}

tensor atg_log1p_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::log1p_out(*result, *self));
  )
}

tensor atg_log2(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::log2(*self));
  )
}

tensor atg_log2_(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::log2_(*self));
  )
}

tensor atg_log2_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::log2_out(*result, *self));
  )
}

tensor atg_log_(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::log_(*self));
  )
}

tensor atg_log_normal_(tensor self, double mean, double std) {
  PROTECT(
    return new torch::Tensor(self->log_normal_(mean, std));
  )
}

tensor atg_log_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::log_out(*result, *self));
  )
}

tensor atg_log_sigmoid(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::log_sigmoid(*self));
  )
}

tensor atg_log_sigmoid_backward(tensor grad_output, tensor self, tensor buffer) {
  PROTECT(
    return new torch::Tensor(torch::log_sigmoid_backward(*grad_output, *self, *buffer));
  )
}

tensor atg_log_sigmoid_backward_out(tensor grad_input, tensor grad_output, tensor self, tensor buffer) {
  PROTECT(
    return new torch::Tensor(torch::log_sigmoid_backward_out(*grad_input, *grad_output, *self, *buffer));
  )
}

tensor atg_log_sigmoid_out(tensor output, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::log_sigmoid_out(*output, *self));
  )
}

tensor atg_log_softmax(tensor self, int64_t dim) {
  PROTECT(
    return new torch::Tensor(torch::log_softmax(*self, dim));
  )
}

tensor atg_log_softmax_backward_data(tensor grad_output, tensor output, int64_t dim, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::log_softmax_backward_data(*grad_output, *output, dim, *self));
  )
}

tensor atg_logdet(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::logdet(*self));
  )
}

tensor atg_logsumexp(tensor self, int64_t dim, int keepdim) {
  PROTECT(
    return new torch::Tensor(torch::logsumexp(*self, dim, (bool)keepdim));
  )
}

tensor atg_logsumexp_out(tensor result, tensor self, int64_t dim, int keepdim) {
  PROTECT(
    return new torch::Tensor(torch::logsumexp_out(*result, *self, dim, (bool)keepdim));
  )
}

tensor atg_lt(tensor self, tensor other) {
  PROTECT(
    return new torch::Tensor(torch::lt(*self, *other));
  )
}

tensor atg_lt_(tensor self, tensor other) {
  PROTECT(
    return new torch::Tensor(self->lt_(*other));
  )
}

tensor atg_margin_ranking_loss(tensor input1, tensor input2, tensor target, double margin, int64_t reduction) {
  PROTECT(
    return new torch::Tensor(torch::margin_ranking_loss(*input1, *input2, *target, margin, reduction));
  )
}

tensor atg_matmul(tensor self, tensor other) {
  PROTECT(
    return new torch::Tensor(torch::matmul(*self, *other));
  )
}

tensor atg_matmul_out(tensor result, tensor self, tensor other) {
  PROTECT(
    return new torch::Tensor(torch::matmul_out(*result, *self, *other));
  )
}

tensor atg_matrix_power(tensor self, int64_t n) {
  PROTECT(
    return new torch::Tensor(torch::matrix_power(*self, n));
  )
}

tensor atg_matrix_rank1(tensor self, double tol, int symmetric) {
  PROTECT(
    return new torch::Tensor(torch::matrix_rank(*self, tol, (bool)symmetric));
  )
}

tensor atg_matrix_rank2(tensor self, int symmetric) {
  PROTECT(
    return new torch::Tensor(torch::matrix_rank(*self, (bool)symmetric));
  )
}

tensor atg_max(tensor self, tensor other) {
  PROTECT(
    return new torch::Tensor(torch::max(*self, *other));
  )
}

tensor atg_max_out(tensor result, tensor self, tensor other) {
  PROTECT(
    return new torch::Tensor(torch::max_out(*result, *self, *other));
  )
}

tensor atg_max_pool1d(tensor self, int *kernel_size_data, int kernel_size_len, int *stride_data, int stride_len, int *padding_data, int padding_len, int *dilation_data, int dilation_len, int ceil_mode) {
  PROTECT(
    return new torch::Tensor(torch::max_pool1d(*self, of_carray(kernel_size_data, kernel_size_len), of_carray(stride_data, stride_len), of_carray(padding_data, padding_len), of_carray(dilation_data, dilation_len), (bool)ceil_mode));
  )
}

tensor atg_max_pool2d(tensor self, int *kernel_size_data, int kernel_size_len, int *stride_data, int stride_len, int *padding_data, int padding_len, int *dilation_data, int dilation_len, int ceil_mode) {
  PROTECT(
    return new torch::Tensor(torch::max_pool2d(*self, of_carray(kernel_size_data, kernel_size_len), of_carray(stride_data, stride_len), of_carray(padding_data, padding_len), of_carray(dilation_data, dilation_len), (bool)ceil_mode));
  )
}

tensor atg_max_pool3d(tensor self, int *kernel_size_data, int kernel_size_len, int *stride_data, int stride_len, int *padding_data, int padding_len, int *dilation_data, int dilation_len, int ceil_mode) {
  PROTECT(
    return new torch::Tensor(torch::max_pool3d(*self, of_carray(kernel_size_data, kernel_size_len), of_carray(stride_data, stride_len), of_carray(padding_data, padding_len), of_carray(dilation_data, dilation_len), (bool)ceil_mode));
  )
}

tensor atg_max_values(tensor self, int64_t dim, int keepdim) {
  PROTECT(
    return new torch::Tensor(torch::max_values(*self, dim, (bool)keepdim));
  )
}

tensor atg_mean1(tensor self, int dtype) {
  PROTECT(
    return new torch::Tensor(torch::mean(*self, torch::ScalarType(dtype)));
  )
}

tensor atg_mean2(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::mean(*self));
  )
}

tensor atg_mean3(tensor self, int64_t dim, int keepdim, int dtype) {
  PROTECT(
    return new torch::Tensor(torch::mean(*self, dim, (bool)keepdim, torch::ScalarType(dtype)));
  )
}

tensor atg_mean4(tensor self, int64_t dim, int keepdim) {
  PROTECT(
    return new torch::Tensor(torch::mean(*self, dim, (bool)keepdim));
  )
}

tensor atg_mean5(tensor self, int64_t dim, int dtype) {
  PROTECT(
    return new torch::Tensor(torch::mean(*self, dim, torch::ScalarType(dtype)));
  )
}

tensor atg_mean_out1(tensor result, tensor self, int64_t dim, int keepdim, int dtype) {
  PROTECT(
    return new torch::Tensor(torch::mean_out(*result, *self, dim, (bool)keepdim, torch::ScalarType(dtype)));
  )
}

tensor atg_mean_out2(tensor result, tensor self, int64_t dim, int keepdim) {
  PROTECT(
    return new torch::Tensor(torch::mean_out(*result, *self, dim, (bool)keepdim));
  )
}

tensor atg_mean_out3(tensor result, tensor self, int64_t dim, int dtype) {
  PROTECT(
    return new torch::Tensor(torch::mean_out(*result, *self, dim, torch::ScalarType(dtype)));
  )
}

tensor atg_min(tensor self, tensor other) {
  PROTECT(
    return new torch::Tensor(torch::min(*self, *other));
  )
}

tensor atg_min_out(tensor result, tensor self, tensor other) {
  PROTECT(
    return new torch::Tensor(torch::min_out(*result, *self, *other));
  )
}

tensor atg_min_values(tensor self, int64_t dim, int keepdim) {
  PROTECT(
    return new torch::Tensor(torch::min_values(*self, dim, (bool)keepdim));
  )
}

tensor atg_miopen_convolution(tensor self, tensor weight, tensor bias, int *padding_data, int padding_len, int *stride_data, int stride_len, int *dilation_data, int dilation_len, int64_t groups, int benchmark, int deterministic) {
  PROTECT(
    return new torch::Tensor(torch::miopen_convolution(*self, *weight, (bias ? *bias : torch::Tensor()), of_carray(padding_data, padding_len), of_carray(stride_data, stride_len), of_carray(dilation_data, dilation_len), groups, (bool)benchmark, (bool)deterministic));
  )
}

tensor atg_miopen_convolution_backward_bias(tensor grad_output) {
  PROTECT(
    return new torch::Tensor(torch::miopen_convolution_backward_bias(*grad_output));
  )
}

tensor atg_miopen_convolution_backward_input(int *self_size_data, int self_size_len, tensor grad_output, tensor weight, int *padding_data, int padding_len, int *stride_data, int stride_len, int *dilation_data, int dilation_len, int64_t groups, int benchmark, int deterministic) {
  PROTECT(
    return new torch::Tensor(torch::miopen_convolution_backward_input(of_carray(self_size_data, self_size_len), *grad_output, *weight, of_carray(padding_data, padding_len), of_carray(stride_data, stride_len), of_carray(dilation_data, dilation_len), groups, (bool)benchmark, (bool)deterministic));
  )
}

tensor atg_miopen_convolution_backward_weight(int *weight_size_data, int weight_size_len, tensor grad_output, tensor self, int *padding_data, int padding_len, int *stride_data, int stride_len, int *dilation_data, int dilation_len, int64_t groups, int benchmark, int deterministic) {
  PROTECT(
    return new torch::Tensor(torch::miopen_convolution_backward_weight(of_carray(weight_size_data, weight_size_len), *grad_output, *self, of_carray(padding_data, padding_len), of_carray(stride_data, stride_len), of_carray(dilation_data, dilation_len), groups, (bool)benchmark, (bool)deterministic));
  )
}

tensor atg_miopen_convolution_transpose(tensor self, tensor weight, tensor bias, int *padding_data, int padding_len, int *output_padding_data, int output_padding_len, int *stride_data, int stride_len, int *dilation_data, int dilation_len, int64_t groups, int benchmark, int deterministic) {
  PROTECT(
    return new torch::Tensor(torch::miopen_convolution_transpose(*self, *weight, (bias ? *bias : torch::Tensor()), of_carray(padding_data, padding_len), of_carray(output_padding_data, output_padding_len), of_carray(stride_data, stride_len), of_carray(dilation_data, dilation_len), groups, (bool)benchmark, (bool)deterministic));
  )
}

tensor atg_miopen_convolution_transpose_backward_input(tensor grad_output, tensor weight, int *padding_data, int padding_len, int *stride_data, int stride_len, int *dilation_data, int dilation_len, int64_t groups, int benchmark, int deterministic) {
  PROTECT(
    return new torch::Tensor(torch::miopen_convolution_transpose_backward_input(*grad_output, *weight, of_carray(padding_data, padding_len), of_carray(stride_data, stride_len), of_carray(dilation_data, dilation_len), groups, (bool)benchmark, (bool)deterministic));
  )
}

tensor atg_miopen_convolution_transpose_backward_weight(int *weight_size_data, int weight_size_len, tensor grad_output, tensor self, int *padding_data, int padding_len, int *stride_data, int stride_len, int *dilation_data, int dilation_len, int64_t groups, int benchmark, int deterministic) {
  PROTECT(
    return new torch::Tensor(torch::miopen_convolution_transpose_backward_weight(of_carray(weight_size_data, weight_size_len), *grad_output, *self, of_carray(padding_data, padding_len), of_carray(stride_data, stride_len), of_carray(dilation_data, dilation_len), groups, (bool)benchmark, (bool)deterministic));
  )
}

tensor atg_mkldnn_convolution(tensor self, tensor weight, tensor bias, int *padding_data, int padding_len, int *stride_data, int stride_len, int *dilation_data, int dilation_len, int64_t groups) {
  PROTECT(
    return new torch::Tensor(torch::mkldnn_convolution(*self, *weight, (bias ? *bias : torch::Tensor()), of_carray(padding_data, padding_len), of_carray(stride_data, stride_len), of_carray(dilation_data, dilation_len), groups));
  )
}

tensor atg_mkldnn_convolution_backward_input(int *self_size_data, int self_size_len, tensor grad_output, tensor weight, int *padding_data, int padding_len, int *stride_data, int stride_len, int *dilation_data, int dilation_len, int64_t groups, int bias_defined) {
  PROTECT(
    return new torch::Tensor(torch::mkldnn_convolution_backward_input(of_carray(self_size_data, self_size_len), *grad_output, *weight, of_carray(padding_data, padding_len), of_carray(stride_data, stride_len), of_carray(dilation_data, dilation_len), groups, (bool)bias_defined));
  )
}

tensor atg_mm(tensor self, tensor mat2) {
  PROTECT(
    return new torch::Tensor(torch::mm(*self, *mat2));
  )
}

tensor atg_mm_out(tensor result, tensor self, tensor mat2) {
  PROTECT(
    return new torch::Tensor(torch::mm_out(*result, *self, *mat2));
  )
}

tensor atg_mse_loss(tensor self, tensor target, int64_t reduction) {
  PROTECT(
    return new torch::Tensor(torch::mse_loss(*self, *target, reduction));
  )
}

tensor atg_mse_loss_backward(tensor grad_output, tensor self, tensor target, int64_t reduction) {
  PROTECT(
    return new torch::Tensor(torch::mse_loss_backward(*grad_output, *self, *target, reduction));
  )
}

tensor atg_mse_loss_backward_out(tensor grad_input, tensor grad_output, tensor self, tensor target, int64_t reduction) {
  PROTECT(
    return new torch::Tensor(torch::mse_loss_backward_out(*grad_input, *grad_output, *self, *target, reduction));
  )
}

tensor atg_mse_loss_forward(tensor self, tensor target, int64_t reduction) {
  PROTECT(
    return new torch::Tensor(torch::mse_loss_forward(*self, *target, reduction));
  )
}

tensor atg_mse_loss_forward_out(tensor output, tensor self, tensor target, int64_t reduction) {
  PROTECT(
    return new torch::Tensor(torch::mse_loss_forward_out(*output, *self, *target, reduction));
  )
}

tensor atg_mse_loss_out(tensor output, tensor self, tensor target, int64_t reduction) {
  PROTECT(
    return new torch::Tensor(torch::mse_loss_out(*output, *self, *target, reduction));
  )
}

tensor atg_mul(tensor self, tensor other) {
  PROTECT(
    return new torch::Tensor(torch::mul(*self, *other));
  )
}

tensor atg_mul_(tensor self, tensor other) {
  PROTECT(
    return new torch::Tensor(self->mul_(*other));
  )
}

tensor atg_mul_out(tensor result, tensor self, tensor other) {
  PROTECT(
    return new torch::Tensor(torch::mul_out(*result, *self, *other));
  )
}

tensor atg_mv(tensor self, tensor vec) {
  PROTECT(
    return new torch::Tensor(torch::mv(*self, *vec));
  )
}

tensor atg_mv_out(tensor result, tensor self, tensor vec) {
  PROTECT(
    return new torch::Tensor(torch::mv_out(*result, *self, *vec));
  )
}

tensor atg_mvlgamma(tensor self, int64_t p) {
  PROTECT(
    return new torch::Tensor(torch::mvlgamma(*self, p));
  )
}

tensor atg_mvlgamma_(tensor self, int64_t p) {
  PROTECT(
    return new torch::Tensor(self->mvlgamma_(p));
  )
}

tensor atg_narrow(tensor self, int64_t dim, int64_t start, int64_t length) {
  PROTECT(
    return new torch::Tensor(torch::narrow(*self, dim, start, length));
  )
}

tensor atg_narrow_copy(tensor self, int64_t dim, int64_t start, int64_t length) {
  PROTECT(
    return new torch::Tensor(self->narrow_copy(dim, start, length));
  )
}

tensor atg_native_clone(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::native_clone(*self));
  )
}

tensor atg_native_norm(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::native_norm(*self));
  )
}

tensor atg_native_resize_as_(tensor self, tensor the_template) {
  PROTECT(
    return new torch::Tensor(torch::native_resize_as_(*self, *the_template));
  )
}

tensor atg_native_zero_(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::native_zero_(*self));
  )
}

tensor atg_ne(tensor self, tensor other) {
  PROTECT(
    return new torch::Tensor(torch::ne(*self, *other));
  )
}

tensor atg_ne_(tensor self, tensor other) {
  PROTECT(
    return new torch::Tensor(self->ne_(*other));
  )
}

tensor atg_neg(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::neg(*self));
  )
}

tensor atg_neg_(tensor self) {
  PROTECT(
    return new torch::Tensor(self->neg_());
  )
}

tensor atg_neg_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::neg_out(*result, *self));
  )
}

tensor atg_norm(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::norm(*self));
  )
}

tensor atg_norm_except_dim(tensor v, int64_t pow, int64_t dim) {
  PROTECT(
    return new torch::Tensor(torch::norm_except_dim(*v, pow, dim));
  )
}

tensor atg_normal1(tensor mean, double std) {
  PROTECT(
    return new torch::Tensor(torch::normal(*mean, std));
  )
}

tensor atg_normal2(double mean, tensor std) {
  PROTECT(
    return new torch::Tensor(torch::normal(mean, *std));
  )
}

tensor atg_normal3(tensor mean, tensor std) {
  PROTECT(
    return new torch::Tensor(torch::normal(*mean, *std));
  )
}

tensor atg_normal_(tensor self, double mean, double std) {
  PROTECT(
    return new torch::Tensor(self->normal_(mean, std));
  )
}

tensor atg_normal_out1(tensor output, tensor mean, double std) {
  PROTECT(
    return new torch::Tensor(torch::normal_out(*output, *mean, std));
  )
}

tensor atg_normal_out2(tensor output, double mean, tensor std) {
  PROTECT(
    return new torch::Tensor(torch::normal_out(*output, mean, *std));
  )
}

tensor atg_normal_out3(tensor output, tensor mean, tensor std) {
  PROTECT(
    return new torch::Tensor(torch::normal_out(*output, *mean, *std));
  )
}

tensor atg_nuclear_norm(tensor self, int keepdim) {
  PROTECT(
    return new torch::Tensor(torch::nuclear_norm(*self, (bool)keepdim));
  )
}

tensor atg_nuclear_norm_out(tensor result, tensor self, int keepdim) {
  PROTECT(
    return new torch::Tensor(torch::nuclear_norm_out(*result, *self, (bool)keepdim));
  )
}

tensor atg_ones(int *size_data, int size_len, int options) {
  PROTECT(
    return new torch::Tensor(torch::ones(of_carray(size_data, size_len), torch::ScalarType(options)));
  )
}

tensor atg_ones_like1(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::ones_like(*self));
  )
}

tensor atg_ones_like2(tensor self, int options) {
  PROTECT(
    return new torch::Tensor(torch::ones_like(*self, torch::ScalarType(options)));
  )
}

tensor atg_ones_out(tensor result, int *size_data, int size_len) {
  PROTECT(
    return new torch::Tensor(torch::ones_out(*result, of_carray(size_data, size_len)));
  )
}

tensor atg_orgqr(tensor self, tensor input2) {
  PROTECT(
    return new torch::Tensor(torch::orgqr(*self, *input2));
  )
}

tensor atg_orgqr_out(tensor result, tensor self, tensor input2) {
  PROTECT(
    return new torch::Tensor(torch::orgqr_out(*result, *self, *input2));
  )
}

tensor atg_ormqr(tensor self, tensor input2, tensor input3, int left, int transpose) {
  PROTECT(
    return new torch::Tensor(torch::ormqr(*self, *input2, *input3, (bool)left, (bool)transpose));
  )
}

tensor atg_ormqr_out(tensor result, tensor self, tensor input2, tensor input3, int left, int transpose) {
  PROTECT(
    return new torch::Tensor(torch::ormqr_out(*result, *self, *input2, *input3, (bool)left, (bool)transpose));
  )
}

tensor atg_pairwise_distance(tensor x1, tensor x2, double p, double eps, int keepdim) {
  PROTECT(
    return new torch::Tensor(torch::pairwise_distance(*x1, *x2, p, eps, (bool)keepdim));
  )
}

tensor atg_pdist(tensor self, double p) {
  PROTECT(
    return new torch::Tensor(torch::pdist(*self, p));
  )
}

tensor atg_permute(tensor self, int *dims_data, int dims_len) {
  PROTECT(
    return new torch::Tensor(self->permute(of_carray(dims_data, dims_len)));
  )
}

tensor atg_pin_memory(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::pin_memory(*self));
  )
}

tensor atg_pinverse(tensor self, double rcond) {
  PROTECT(
    return new torch::Tensor(torch::pinverse(*self, rcond));
  )
}

tensor atg_pixel_shuffle(tensor self, int64_t upscale_factor) {
  PROTECT(
    return new torch::Tensor(torch::pixel_shuffle(*self, upscale_factor));
  )
}

tensor atg_poisson(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::poisson(*self));
  )
}

tensor atg_polygamma(int64_t n, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::polygamma(n, *self));
  )
}

tensor atg_polygamma_(tensor self, int64_t n) {
  PROTECT(
    return new torch::Tensor(self->polygamma_(n));
  )
}

tensor atg_polygamma_out(tensor result, int64_t n, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::polygamma_out(*result, n, *self));
  )
}

tensor atg_potrf(tensor self, int upper) {
  PROTECT(
    return new torch::Tensor(torch::potrf(*self, (bool)upper));
  )
}

tensor atg_potrf_out(tensor output, tensor self, int upper) {
  PROTECT(
    return new torch::Tensor(torch::potrf_out(*output, *self, (bool)upper));
  )
}

tensor atg_potri(tensor self, int upper) {
  PROTECT(
    return new torch::Tensor(torch::potri(*self, (bool)upper));
  )
}

tensor atg_potri_out(tensor output, tensor self, int upper) {
  PROTECT(
    return new torch::Tensor(torch::potri_out(*output, *self, (bool)upper));
  )
}

tensor atg_potrs(tensor self, tensor input2, int upper) {
  PROTECT(
    return new torch::Tensor(torch::potrs(*self, *input2, (bool)upper));
  )
}

tensor atg_potrs_out(tensor result, tensor self, tensor input2, int upper) {
  PROTECT(
    return new torch::Tensor(torch::potrs_out(*result, *self, *input2, (bool)upper));
  )
}

tensor atg_pow(tensor self, tensor exponent) {
  PROTECT(
    return new torch::Tensor(torch::pow(*self, *exponent));
  )
}

tensor atg_pow_(tensor self, tensor exponent) {
  PROTECT(
    return new torch::Tensor(self->pow_(*exponent));
  )
}

tensor atg_pow_out(tensor result, tensor self, tensor exponent) {
  PROTECT(
    return new torch::Tensor(torch::pow_out(*result, *self, *exponent));
  )
}

tensor atg_prelu(tensor self, tensor weight) {
  PROTECT(
    return new torch::Tensor(torch::prelu(*self, *weight));
  )
}

tensor atg_prod1(tensor self, int dtype) {
  PROTECT(
    return new torch::Tensor(torch::prod(*self, torch::ScalarType(dtype)));
  )
}

tensor atg_prod2(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::prod(*self));
  )
}

tensor atg_prod3(tensor self, int64_t dim, int keepdim, int dtype) {
  PROTECT(
    return new torch::Tensor(torch::prod(*self, dim, (bool)keepdim, torch::ScalarType(dtype)));
  )
}

tensor atg_prod4(tensor self, int64_t dim, int keepdim) {
  PROTECT(
    return new torch::Tensor(torch::prod(*self, dim, (bool)keepdim));
  )
}

tensor atg_prod5(tensor self, int64_t dim, int dtype) {
  PROTECT(
    return new torch::Tensor(torch::prod(*self, dim, torch::ScalarType(dtype)));
  )
}

tensor atg_prod_out1(tensor result, tensor self, int64_t dim, int keepdim, int dtype) {
  PROTECT(
    return new torch::Tensor(torch::prod_out(*result, *self, dim, (bool)keepdim, torch::ScalarType(dtype)));
  )
}

tensor atg_prod_out2(tensor result, tensor self, int64_t dim, int keepdim) {
  PROTECT(
    return new torch::Tensor(torch::prod_out(*result, *self, dim, (bool)keepdim));
  )
}

tensor atg_prod_out3(tensor result, tensor self, int64_t dim, int dtype) {
  PROTECT(
    return new torch::Tensor(torch::prod_out(*result, *self, dim, torch::ScalarType(dtype)));
  )
}

tensor atg_rand(int *size_data, int size_len, int options) {
  PROTECT(
    return new torch::Tensor(torch::rand(of_carray(size_data, size_len), torch::ScalarType(options)));
  )
}

tensor atg_rand_like1(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::rand_like(*self));
  )
}

tensor atg_rand_like2(tensor self, int options) {
  PROTECT(
    return new torch::Tensor(torch::rand_like(*self, torch::ScalarType(options)));
  )
}

tensor atg_rand_out(tensor result, int *size_data, int size_len) {
  PROTECT(
    return new torch::Tensor(torch::rand_out(*result, of_carray(size_data, size_len)));
  )
}

tensor atg_randint1(int64_t high, int *size_data, int size_len, int options) {
  PROTECT(
    return new torch::Tensor(torch::randint(high, of_carray(size_data, size_len), torch::ScalarType(options)));
  )
}

tensor atg_randint2(int64_t low, int64_t high, int *size_data, int size_len, int options) {
  PROTECT(
    return new torch::Tensor(torch::randint(low, high, of_carray(size_data, size_len), torch::ScalarType(options)));
  )
}

tensor atg_randint_like1(tensor self, int64_t high) {
  PROTECT(
    return new torch::Tensor(torch::randint_like(*self, high));
  )
}

tensor atg_randint_like2(tensor self, int64_t low, int64_t high) {
  PROTECT(
    return new torch::Tensor(torch::randint_like(*self, low, high));
  )
}

tensor atg_randint_like3(tensor self, int64_t high, int options) {
  PROTECT(
    return new torch::Tensor(torch::randint_like(*self, high, torch::ScalarType(options)));
  )
}

tensor atg_randint_like4(tensor self, int64_t low, int64_t high, int options) {
  PROTECT(
    return new torch::Tensor(torch::randint_like(*self, low, high, torch::ScalarType(options)));
  )
}

tensor atg_randint_out1(tensor result, int64_t high, int *size_data, int size_len) {
  PROTECT(
    return new torch::Tensor(torch::randint_out(*result, high, of_carray(size_data, size_len)));
  )
}

tensor atg_randint_out2(tensor result, int64_t low, int64_t high, int *size_data, int size_len) {
  PROTECT(
    return new torch::Tensor(torch::randint_out(*result, low, high, of_carray(size_data, size_len)));
  )
}

tensor atg_randn(int *size_data, int size_len, int options) {
  PROTECT(
    return new torch::Tensor(torch::randn(of_carray(size_data, size_len), torch::ScalarType(options)));
  )
}

tensor atg_randn_like1(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::randn_like(*self));
  )
}

tensor atg_randn_like2(tensor self, int options) {
  PROTECT(
    return new torch::Tensor(torch::randn_like(*self, torch::ScalarType(options)));
  )
}

tensor atg_randn_out(tensor result, int *size_data, int size_len) {
  PROTECT(
    return new torch::Tensor(torch::randn_out(*result, of_carray(size_data, size_len)));
  )
}

tensor atg_random_1(tensor self, int64_t from, int64_t to) {
  PROTECT(
    return new torch::Tensor(self->random_(from, to));
  )
}

tensor atg_random_2(tensor self, int64_t to) {
  PROTECT(
    return new torch::Tensor(self->random_(to));
  )
}

tensor atg_random_3(tensor self) {
  PROTECT(
    return new torch::Tensor(self->random_());
  )
}

tensor atg_randperm(int64_t n, int options) {
  PROTECT(
    return new torch::Tensor(torch::randperm(n, torch::ScalarType(options)));
  )
}

tensor atg_randperm_out(tensor result, int64_t n) {
  PROTECT(
    return new torch::Tensor(torch::randperm_out(*result, n));
  )
}

tensor atg_reciprocal(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::reciprocal(*self));
  )
}

tensor atg_reciprocal_(tensor self) {
  PROTECT(
    return new torch::Tensor(self->reciprocal_());
  )
}

tensor atg_reciprocal_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::reciprocal_out(*result, *self));
  )
}

tensor atg_reflection_pad1d(tensor self, int *padding_data, int padding_len) {
  PROTECT(
    return new torch::Tensor(torch::reflection_pad1d(*self, of_carray(padding_data, padding_len)));
  )
}

tensor atg_reflection_pad1d_backward(tensor grad_output, tensor self, int *padding_data, int padding_len) {
  PROTECT(
    return new torch::Tensor(torch::reflection_pad1d_backward(*grad_output, *self, of_carray(padding_data, padding_len)));
  )
}

tensor atg_reflection_pad1d_backward_out(tensor grad_input, tensor grad_output, tensor self, int *padding_data, int padding_len) {
  PROTECT(
    return new torch::Tensor(torch::reflection_pad1d_backward_out(*grad_input, *grad_output, *self, of_carray(padding_data, padding_len)));
  )
}

tensor atg_reflection_pad1d_forward(tensor self, int *padding_data, int padding_len) {
  PROTECT(
    return new torch::Tensor(torch::reflection_pad1d_forward(*self, of_carray(padding_data, padding_len)));
  )
}

tensor atg_reflection_pad1d_forward_out(tensor output, tensor self, int *padding_data, int padding_len) {
  PROTECT(
    return new torch::Tensor(torch::reflection_pad1d_forward_out(*output, *self, of_carray(padding_data, padding_len)));
  )
}

tensor atg_reflection_pad1d_out(tensor output, tensor self, int *padding_data, int padding_len) {
  PROTECT(
    return new torch::Tensor(torch::reflection_pad1d_out(*output, *self, of_carray(padding_data, padding_len)));
  )
}

tensor atg_reflection_pad2d(tensor self, int *padding_data, int padding_len) {
  PROTECT(
    return new torch::Tensor(torch::reflection_pad2d(*self, of_carray(padding_data, padding_len)));
  )
}

tensor atg_reflection_pad2d_backward(tensor grad_output, tensor self, int *padding_data, int padding_len) {
  PROTECT(
    return new torch::Tensor(torch::reflection_pad2d_backward(*grad_output, *self, of_carray(padding_data, padding_len)));
  )
}

tensor atg_reflection_pad2d_backward_out(tensor grad_input, tensor grad_output, tensor self, int *padding_data, int padding_len) {
  PROTECT(
    return new torch::Tensor(torch::reflection_pad2d_backward_out(*grad_input, *grad_output, *self, of_carray(padding_data, padding_len)));
  )
}

tensor atg_reflection_pad2d_forward(tensor self, int *padding_data, int padding_len) {
  PROTECT(
    return new torch::Tensor(torch::reflection_pad2d_forward(*self, of_carray(padding_data, padding_len)));
  )
}

tensor atg_reflection_pad2d_forward_out(tensor output, tensor self, int *padding_data, int padding_len) {
  PROTECT(
    return new torch::Tensor(torch::reflection_pad2d_forward_out(*output, *self, of_carray(padding_data, padding_len)));
  )
}

tensor atg_reflection_pad2d_out(tensor output, tensor self, int *padding_data, int padding_len) {
  PROTECT(
    return new torch::Tensor(torch::reflection_pad2d_out(*output, *self, of_carray(padding_data, padding_len)));
  )
}

tensor atg_relu(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::relu(*self));
  )
}

tensor atg_relu_(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::relu_(*self));
  )
}

tensor atg_remainder(tensor self, tensor other) {
  PROTECT(
    return new torch::Tensor(torch::remainder(*self, *other));
  )
}

tensor atg_remainder_(tensor self, tensor other) {
  PROTECT(
    return new torch::Tensor(self->remainder_(*other));
  )
}

tensor atg_remainder_out(tensor result, tensor self, tensor other) {
  PROTECT(
    return new torch::Tensor(torch::remainder_out(*result, *self, *other));
  )
}

tensor atg_repeat(tensor self, int *repeats_data, int repeats_len) {
  PROTECT(
    return new torch::Tensor(self->repeat(of_carray(repeats_data, repeats_len)));
  )
}

tensor atg_replication_pad1d(tensor self, int *padding_data, int padding_len) {
  PROTECT(
    return new torch::Tensor(torch::replication_pad1d(*self, of_carray(padding_data, padding_len)));
  )
}

tensor atg_replication_pad1d_backward(tensor grad_output, tensor self, int *padding_data, int padding_len) {
  PROTECT(
    return new torch::Tensor(torch::replication_pad1d_backward(*grad_output, *self, of_carray(padding_data, padding_len)));
  )
}

tensor atg_replication_pad1d_backward_out(tensor grad_input, tensor grad_output, tensor self, int *padding_data, int padding_len) {
  PROTECT(
    return new torch::Tensor(torch::replication_pad1d_backward_out(*grad_input, *grad_output, *self, of_carray(padding_data, padding_len)));
  )
}

tensor atg_replication_pad1d_forward(tensor self, int *padding_data, int padding_len) {
  PROTECT(
    return new torch::Tensor(torch::replication_pad1d_forward(*self, of_carray(padding_data, padding_len)));
  )
}

tensor atg_replication_pad1d_forward_out(tensor output, tensor self, int *padding_data, int padding_len) {
  PROTECT(
    return new torch::Tensor(torch::replication_pad1d_forward_out(*output, *self, of_carray(padding_data, padding_len)));
  )
}

tensor atg_replication_pad1d_out(tensor output, tensor self, int *padding_data, int padding_len) {
  PROTECT(
    return new torch::Tensor(torch::replication_pad1d_out(*output, *self, of_carray(padding_data, padding_len)));
  )
}

tensor atg_replication_pad2d(tensor self, int *padding_data, int padding_len) {
  PROTECT(
    return new torch::Tensor(torch::replication_pad2d(*self, of_carray(padding_data, padding_len)));
  )
}

tensor atg_replication_pad2d_backward(tensor grad_output, tensor self, int *padding_data, int padding_len) {
  PROTECT(
    return new torch::Tensor(torch::replication_pad2d_backward(*grad_output, *self, of_carray(padding_data, padding_len)));
  )
}

tensor atg_replication_pad2d_backward_out(tensor grad_input, tensor grad_output, tensor self, int *padding_data, int padding_len) {
  PROTECT(
    return new torch::Tensor(torch::replication_pad2d_backward_out(*grad_input, *grad_output, *self, of_carray(padding_data, padding_len)));
  )
}

tensor atg_replication_pad2d_forward(tensor self, int *padding_data, int padding_len) {
  PROTECT(
    return new torch::Tensor(torch::replication_pad2d_forward(*self, of_carray(padding_data, padding_len)));
  )
}

tensor atg_replication_pad2d_forward_out(tensor output, tensor self, int *padding_data, int padding_len) {
  PROTECT(
    return new torch::Tensor(torch::replication_pad2d_forward_out(*output, *self, of_carray(padding_data, padding_len)));
  )
}

tensor atg_replication_pad2d_out(tensor output, tensor self, int *padding_data, int padding_len) {
  PROTECT(
    return new torch::Tensor(torch::replication_pad2d_out(*output, *self, of_carray(padding_data, padding_len)));
  )
}

tensor atg_replication_pad3d(tensor self, int *padding_data, int padding_len) {
  PROTECT(
    return new torch::Tensor(torch::replication_pad3d(*self, of_carray(padding_data, padding_len)));
  )
}

tensor atg_replication_pad3d_backward(tensor grad_output, tensor self, int *padding_data, int padding_len) {
  PROTECT(
    return new torch::Tensor(torch::replication_pad3d_backward(*grad_output, *self, of_carray(padding_data, padding_len)));
  )
}

tensor atg_replication_pad3d_backward_out(tensor grad_input, tensor grad_output, tensor self, int *padding_data, int padding_len) {
  PROTECT(
    return new torch::Tensor(torch::replication_pad3d_backward_out(*grad_input, *grad_output, *self, of_carray(padding_data, padding_len)));
  )
}

tensor atg_replication_pad3d_forward(tensor self, int *padding_data, int padding_len) {
  PROTECT(
    return new torch::Tensor(torch::replication_pad3d_forward(*self, of_carray(padding_data, padding_len)));
  )
}

tensor atg_replication_pad3d_forward_out(tensor output, tensor self, int *padding_data, int padding_len) {
  PROTECT(
    return new torch::Tensor(torch::replication_pad3d_forward_out(*output, *self, of_carray(padding_data, padding_len)));
  )
}

tensor atg_replication_pad3d_out(tensor output, tensor self, int *padding_data, int padding_len) {
  PROTECT(
    return new torch::Tensor(torch::replication_pad3d_out(*output, *self, of_carray(padding_data, padding_len)));
  )
}

tensor atg_reshape(tensor self, int *shape_data, int shape_len) {
  PROTECT(
    return new torch::Tensor(torch::reshape(*self, of_carray(shape_data, shape_len)));
  )
}

tensor atg_reshape_as(tensor self, tensor other) {
  PROTECT(
    return new torch::Tensor(self->reshape_as(*other));
  )
}

tensor atg_resize_(tensor self, int *size_data, int size_len) {
  PROTECT(
    return new torch::Tensor(self->resize_(of_carray(size_data, size_len)));
  )
}

tensor atg_resize_as_(tensor self, tensor the_template) {
  PROTECT(
    return new torch::Tensor(torch::resize_as_(*self, *the_template));
  )
}

tensor atg_rfft(tensor self, int64_t signal_ndim, int normalized, int onesided) {
  PROTECT(
    return new torch::Tensor(torch::rfft(*self, signal_ndim, (bool)normalized, (bool)onesided));
  )
}

tensor atg_rnn_relu_cell(tensor input, tensor hx, tensor w_ih, tensor w_hh, tensor b_ih, tensor b_hh) {
  PROTECT(
    return new torch::Tensor(torch::rnn_relu_cell(*input, *hx, *w_ih, *w_hh, (b_ih ? *b_ih : torch::Tensor()), (b_hh ? *b_hh : torch::Tensor())));
  )
}

tensor atg_rnn_tanh_cell(tensor input, tensor hx, tensor w_ih, tensor w_hh, tensor b_ih, tensor b_hh) {
  PROTECT(
    return new torch::Tensor(torch::rnn_tanh_cell(*input, *hx, *w_ih, *w_hh, (b_ih ? *b_ih : torch::Tensor()), (b_hh ? *b_hh : torch::Tensor())));
  )
}

tensor atg_roipooling2d_backward(tensor input, tensor rois, int64_t pooledHeight, int64_t pooledWidth, double spatialScale, tensor gradOutput, tensor argmaxes) {
  PROTECT(
    return new torch::Tensor(torch::RoiPooling2d_backward(*input, *rois, pooledHeight, pooledWidth, spatialScale, *gradOutput, *argmaxes));
  )
}

tensor atg_round(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::round(*self));
  )
}

tensor atg_round_(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::round_(*self));
  )
}

tensor atg_round_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::round_out(*result, *self));
  )
}

tensor atg_rrelu(tensor self, int training) {
  PROTECT(
    return new torch::Tensor(torch::rrelu(*self, (bool)training));
  )
}

tensor atg_rrelu_(tensor self, int training) {
  PROTECT(
    return new torch::Tensor(torch::rrelu_(*self, (bool)training));
  )
}

tensor atg_rrelu_with_noise(tensor self, tensor noise, int training) {
  PROTECT(
    return new torch::Tensor(torch::rrelu_with_noise(*self, *noise, (bool)training));
  )
}

tensor atg_rrelu_with_noise_(tensor self, tensor noise, int training) {
  PROTECT(
    return new torch::Tensor(torch::rrelu_with_noise_(*self, *noise, (bool)training));
  )
}

tensor atg_rrelu_with_noise_out(tensor output, tensor self, tensor noise, int training) {
  PROTECT(
    return new torch::Tensor(torch::rrelu_with_noise_out(*output, *self, *noise, (bool)training));
  )
}

tensor atg_rsqrt(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::rsqrt(*self));
  )
}

tensor atg_rsqrt_(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::rsqrt_(*self));
  )
}

tensor atg_rsqrt_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::rsqrt_out(*result, *self));
  )
}

tensor atg_s_native_addmm(tensor self, tensor mat1, tensor mat2) {
  PROTECT(
    return new torch::Tensor(torch::s_native_addmm(*self, *mat1, *mat2));
  )
}

tensor atg_s_native_addmm_(tensor self, tensor mat1, tensor mat2) {
  PROTECT(
    return new torch::Tensor(torch::s_native_addmm_(*self, *mat1, *mat2));
  )
}

tensor atg_s_native_addmm_out(tensor result, tensor self, tensor mat1, tensor mat2) {
  PROTECT(
    return new torch::Tensor(torch::s_native_addmm_out(*result, *self, *mat1, *mat2));
  )
}

tensor atg_select(tensor self, int64_t dim, int64_t index) {
  PROTECT(
    return new torch::Tensor(torch::select(*self, dim, index));
  )
}

tensor atg_selu(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::selu(*self));
  )
}

tensor atg_selu_(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::selu_(*self));
  )
}

tensor atg_set_1(tensor self, tensor source) {
  PROTECT(
    return new torch::Tensor(self->set_(*source));
  )
}

tensor atg_set_2(tensor self) {
  PROTECT(
    return new torch::Tensor(self->set_());
  )
}

tensor atg_set_requires_grad(tensor self, int r) {
  PROTECT(
    return new torch::Tensor(self->set_requires_grad((bool)r));
  )
}

tensor atg_sigmoid(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::sigmoid(*self));
  )
}

tensor atg_sigmoid_(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::sigmoid_(*self));
  )
}

tensor atg_sigmoid_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::sigmoid_out(*result, *self));
  )
}

tensor atg_sign(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::sign(*self));
  )
}

tensor atg_sign_(tensor self) {
  PROTECT(
    return new torch::Tensor(self->sign_());
  )
}

tensor atg_sign_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::sign_out(*result, *self));
  )
}

tensor atg_sin(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::sin(*self));
  )
}

tensor atg_sin_(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::sin_(*self));
  )
}

tensor atg_sin_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::sin_out(*result, *self));
  )
}

tensor atg_sinh(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::sinh(*self));
  )
}

tensor atg_sinh_(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::sinh_(*self));
  )
}

tensor atg_sinh_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::sinh_out(*result, *self));
  )
}

tensor atg_slice(tensor self, int64_t dim, int64_t start, int64_t end, int64_t step) {
  PROTECT(
    return new torch::Tensor(torch::slice(*self, dim, start, end, step));
  )
}

tensor atg_smm(tensor self, tensor mat2) {
  PROTECT(
    return new torch::Tensor(torch::smm(*self, *mat2));
  )
}

tensor atg_smooth_l1_loss(tensor self, tensor target, int64_t reduction) {
  PROTECT(
    return new torch::Tensor(torch::smooth_l1_loss(*self, *target, reduction));
  )
}

tensor atg_smooth_l1_loss_backward(tensor grad_output, tensor self, tensor target, int64_t reduction) {
  PROTECT(
    return new torch::Tensor(torch::smooth_l1_loss_backward(*grad_output, *self, *target, reduction));
  )
}

tensor atg_smooth_l1_loss_backward_out(tensor grad_input, tensor grad_output, tensor self, tensor target, int64_t reduction) {
  PROTECT(
    return new torch::Tensor(torch::smooth_l1_loss_backward_out(*grad_input, *grad_output, *self, *target, reduction));
  )
}

tensor atg_smooth_l1_loss_forward(tensor self, tensor target, int64_t reduction) {
  PROTECT(
    return new torch::Tensor(torch::smooth_l1_loss_forward(*self, *target, reduction));
  )
}

tensor atg_smooth_l1_loss_forward_out(tensor output, tensor self, tensor target, int64_t reduction) {
  PROTECT(
    return new torch::Tensor(torch::smooth_l1_loss_forward_out(*output, *self, *target, reduction));
  )
}

tensor atg_smooth_l1_loss_out(tensor output, tensor self, tensor target, int64_t reduction) {
  PROTECT(
    return new torch::Tensor(torch::smooth_l1_loss_out(*output, *self, *target, reduction));
  )
}

tensor atg_soft_margin_loss(tensor self, tensor target, int64_t reduction) {
  PROTECT(
    return new torch::Tensor(torch::soft_margin_loss(*self, *target, reduction));
  )
}

tensor atg_soft_margin_loss_backward(tensor grad_output, tensor self, tensor target, int64_t reduction) {
  PROTECT(
    return new torch::Tensor(torch::soft_margin_loss_backward(*grad_output, *self, *target, reduction));
  )
}

tensor atg_soft_margin_loss_backward_out(tensor grad_input, tensor grad_output, tensor self, tensor target, int64_t reduction) {
  PROTECT(
    return new torch::Tensor(torch::soft_margin_loss_backward_out(*grad_input, *grad_output, *self, *target, reduction));
  )
}

tensor atg_soft_margin_loss_forward(tensor self, tensor target, int64_t reduction) {
  PROTECT(
    return new torch::Tensor(torch::soft_margin_loss_forward(*self, *target, reduction));
  )
}

tensor atg_soft_margin_loss_forward_out(tensor output, tensor self, tensor target, int64_t reduction) {
  PROTECT(
    return new torch::Tensor(torch::soft_margin_loss_forward_out(*output, *self, *target, reduction));
  )
}

tensor atg_soft_margin_loss_out(tensor output, tensor self, tensor target, int64_t reduction) {
  PROTECT(
    return new torch::Tensor(torch::soft_margin_loss_out(*output, *self, *target, reduction));
  )
}

tensor atg_softmax(tensor self, int64_t dim) {
  PROTECT(
    return new torch::Tensor(torch::softmax(*self, dim));
  )
}

tensor atg_softmax_backward_data(tensor grad_output, tensor output, int64_t dim, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::softmax_backward_data(*grad_output, *output, dim, *self));
  )
}

tensor atg_softplus(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::softplus(*self));
  )
}

tensor atg_softplus_out(tensor output, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::softplus_out(*output, *self));
  )
}

tensor atg_softshrink(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::softshrink(*self));
  )
}

tensor atg_softshrink_out(tensor output, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::softshrink_out(*output, *self));
  )
}

tensor atg_sparse_coo_tensor(int *size_data, int size_len, int options) {
  PROTECT(
    return new torch::Tensor(torch::sparse_coo_tensor(of_carray(size_data, size_len), torch::ScalarType(options)));
  )
}

tensor atg_sparse_resize_(tensor self, int *size_data, int size_len, int64_t sparseDims, int64_t denseDims) {
  PROTECT(
    return new torch::Tensor(self->sparse_resize_(of_carray(size_data, size_len), sparseDims, denseDims));
  )
}

tensor atg_sparse_resize_and_clear_(tensor self, int *size_data, int size_len, int64_t sparseDims, int64_t denseDims) {
  PROTECT(
    return new torch::Tensor(self->sparse_resize_and_clear_(of_carray(size_data, size_len), sparseDims, denseDims));
  )
}

tensor atg_sqrt(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::sqrt(*self));
  )
}

tensor atg_sqrt_(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::sqrt_(*self));
  )
}

tensor atg_sqrt_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::sqrt_out(*result, *self));
  )
}

tensor atg_squeeze1(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::squeeze(*self));
  )
}

tensor atg_squeeze2(tensor self, int64_t dim) {
  PROTECT(
    return new torch::Tensor(torch::squeeze(*self, dim));
  )
}

tensor atg_squeeze_1(tensor self) {
  PROTECT(
    return new torch::Tensor(self->squeeze_());
  )
}

tensor atg_squeeze_2(tensor self, int64_t dim) {
  PROTECT(
    return new torch::Tensor(self->squeeze_(dim));
  )
}

tensor atg_sspaddmm(tensor self, tensor mat1, tensor mat2) {
  PROTECT(
    return new torch::Tensor(torch::sspaddmm(*self, *mat1, *mat2));
  )
}

tensor atg_sspaddmm_out(tensor result, tensor self, tensor mat1, tensor mat2) {
  PROTECT(
    return new torch::Tensor(torch::sspaddmm_out(*result, *self, *mat1, *mat2));
  )
}

tensor atg_std1(tensor self, int unbiased) {
  PROTECT(
    return new torch::Tensor(torch::std(*self, (bool)unbiased));
  )
}

tensor atg_std2(tensor self, int64_t dim, int unbiased, int keepdim) {
  PROTECT(
    return new torch::Tensor(torch::std(*self, dim, (bool)unbiased, (bool)keepdim));
  )
}

tensor atg_std_out(tensor result, tensor self, int64_t dim, int unbiased, int keepdim) {
  PROTECT(
    return new torch::Tensor(torch::std_out(*result, *self, dim, (bool)unbiased, (bool)keepdim));
  )
}

tensor atg_sub(tensor self, tensor other) {
  PROTECT(
    return new torch::Tensor(torch::sub(*self, *other));
  )
}

tensor atg_sub_(tensor self, tensor other) {
  PROTECT(
    return new torch::Tensor(self->sub_(*other));
  )
}

tensor atg_sub_out(tensor result, tensor self, tensor other) {
  PROTECT(
    return new torch::Tensor(torch::sub_out(*result, *self, *other));
  )
}

tensor atg_sum1(tensor self, int dtype) {
  PROTECT(
    return new torch::Tensor(torch::sum(*self, torch::ScalarType(dtype)));
  )
}

tensor atg_sum2(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::sum(*self));
  )
}

tensor atg_sum3(tensor self, int *dim_data, int dim_len, int keepdim, int dtype) {
  PROTECT(
    return new torch::Tensor(torch::sum(*self, of_carray(dim_data, dim_len), (bool)keepdim, torch::ScalarType(dtype)));
  )
}

tensor atg_sum4(tensor self, int *dim_data, int dim_len, int keepdim) {
  PROTECT(
    return new torch::Tensor(torch::sum(*self, of_carray(dim_data, dim_len), (bool)keepdim));
  )
}

tensor atg_sum5(tensor self, int *dim_data, int dim_len, int dtype) {
  PROTECT(
    return new torch::Tensor(torch::sum(*self, of_carray(dim_data, dim_len), torch::ScalarType(dtype)));
  )
}

tensor atg_sum_out1(tensor result, tensor self, int *dim_data, int dim_len, int keepdim, int dtype) {
  PROTECT(
    return new torch::Tensor(torch::sum_out(*result, *self, of_carray(dim_data, dim_len), (bool)keepdim, torch::ScalarType(dtype)));
  )
}

tensor atg_sum_out2(tensor result, tensor self, int *dim_data, int dim_len, int keepdim) {
  PROTECT(
    return new torch::Tensor(torch::sum_out(*result, *self, of_carray(dim_data, dim_len), (bool)keepdim));
  )
}

tensor atg_sum_out3(tensor result, tensor self, int *dim_data, int dim_len, int dtype) {
  PROTECT(
    return new torch::Tensor(torch::sum_out(*result, *self, of_carray(dim_data, dim_len), torch::ScalarType(dtype)));
  )
}

tensor atg_t_(tensor self) {
  PROTECT(
    return new torch::Tensor(self->t_());
  )
}

tensor atg_tan(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::tan(*self));
  )
}

tensor atg_tan_(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::tan_(*self));
  )
}

tensor atg_tan_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::tan_out(*result, *self));
  )
}

tensor atg_tanh(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::tanh(*self));
  )
}

tensor atg_tanh_(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::tanh_(*self));
  )
}

tensor atg_tanh_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::tanh_out(*result, *self));
  )
}

tensor atg_tensordot(tensor self, tensor other, int *dims_self_data, int dims_self_len, int *dims_other_data, int dims_other_len) {
  PROTECT(
    return new torch::Tensor(torch::tensordot(*self, *other, of_carray(dims_self_data, dims_self_len), of_carray(dims_other_data, dims_other_len)));
  )
}

tensor atg_th_addmm(tensor self, tensor mat1, tensor mat2) {
  PROTECT(
    return new torch::Tensor(torch::th_addmm(*self, *mat1, *mat2));
  )
}

tensor atg_th_addmm_(tensor self, tensor mat1, tensor mat2) {
  PROTECT(
    return new torch::Tensor(torch::th_addmm_(*self, *mat1, *mat2));
  )
}

tensor atg_th_addmm_out(tensor result, tensor self, tensor mat1, tensor mat2) {
  PROTECT(
    return new torch::Tensor(torch::th_addmm_out(*result, *self, *mat1, *mat2));
  )
}

tensor atg_th_clone(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::th_clone(*self));
  )
}

tensor atg_th_resize_as_(tensor self, tensor the_template) {
  PROTECT(
    return new torch::Tensor(torch::th_resize_as_(*self, *the_template));
  )
}

tensor atg_th_zero_(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::th_zero_(*self));
  )
}

tensor atg_thnn_batch_norm(tensor self, tensor weight, tensor bias, tensor running_mean, tensor running_var, int training, double momentum, double eps) {
  PROTECT(
    return new torch::Tensor(torch::thnn_batch_norm(*self, *weight, *bias, *running_mean, *running_var, (bool)training, momentum, eps));
  )
}

tensor atg_thnn_batch_norm_out(tensor output, tensor self, tensor weight, tensor bias, tensor running_mean, tensor running_var, int training, double momentum, double eps) {
  PROTECT(
    return new torch::Tensor(torch::thnn_batch_norm_out(*output, *self, *weight, *bias, *running_mean, *running_var, (bool)training, momentum, eps));
  )
}

tensor atg_thnn_conv2d(tensor self, tensor weight, int *kernel_size_data, int kernel_size_len, tensor bias, int *stride_data, int stride_len, int *padding_data, int padding_len) {
  PROTECT(
    return new torch::Tensor(torch::thnn_conv2d(*self, *weight, of_carray(kernel_size_data, kernel_size_len), *bias, of_carray(stride_data, stride_len), of_carray(padding_data, padding_len)));
  )
}

tensor atg_thnn_conv2d_out(tensor output, tensor self, tensor weight, int *kernel_size_data, int kernel_size_len, tensor bias, int *stride_data, int stride_len, int *padding_data, int padding_len) {
  PROTECT(
    return new torch::Tensor(torch::thnn_conv2d_out(*output, *self, *weight, of_carray(kernel_size_data, kernel_size_len), *bias, of_carray(stride_data, stride_len), of_carray(padding_data, padding_len)));
  )
}

tensor atg_thnn_conv3d(tensor self, tensor weight, int *kernel_size_data, int kernel_size_len, tensor bias, int *stride_data, int stride_len, int *padding_data, int padding_len) {
  PROTECT(
    return new torch::Tensor(torch::thnn_conv3d(*self, *weight, of_carray(kernel_size_data, kernel_size_len), *bias, of_carray(stride_data, stride_len), of_carray(padding_data, padding_len)));
  )
}

tensor atg_thnn_conv3d_out(tensor output, tensor self, tensor weight, int *kernel_size_data, int kernel_size_len, tensor bias, int *stride_data, int stride_len, int *padding_data, int padding_len) {
  PROTECT(
    return new torch::Tensor(torch::thnn_conv3d_out(*output, *self, *weight, of_carray(kernel_size_data, kernel_size_len), *bias, of_carray(stride_data, stride_len), of_carray(padding_data, padding_len)));
  )
}

tensor atg_thnn_conv_depthwise2d(tensor self, tensor weight, int *kernel_size_data, int kernel_size_len, tensor bias, int *stride_data, int stride_len, int *padding_data, int padding_len, int *dilation_data, int dilation_len) {
  PROTECT(
    return new torch::Tensor(torch::thnn_conv_depthwise2d(*self, *weight, of_carray(kernel_size_data, kernel_size_len), *bias, of_carray(stride_data, stride_len), of_carray(padding_data, padding_len), of_carray(dilation_data, dilation_len)));
  )
}

tensor atg_thnn_conv_depthwise2d_forward(tensor self, tensor weight, int *kernel_size_data, int kernel_size_len, tensor bias, int *stride_data, int stride_len, int *padding_data, int padding_len, int *dilation_data, int dilation_len) {
  PROTECT(
    return new torch::Tensor(torch::thnn_conv_depthwise2d_forward(*self, *weight, of_carray(kernel_size_data, kernel_size_len), (bias ? *bias : torch::Tensor()), of_carray(stride_data, stride_len), of_carray(padding_data, padding_len), of_carray(dilation_data, dilation_len)));
  )
}

tensor atg_thnn_conv_depthwise2d_forward_out(tensor output, tensor self, tensor weight, int *kernel_size_data, int kernel_size_len, tensor bias, int *stride_data, int stride_len, int *padding_data, int padding_len, int *dilation_data, int dilation_len) {
  PROTECT(
    return new torch::Tensor(torch::thnn_conv_depthwise2d_forward_out(*output, *self, *weight, of_carray(kernel_size_data, kernel_size_len), (bias ? *bias : torch::Tensor()), of_carray(stride_data, stride_len), of_carray(padding_data, padding_len), of_carray(dilation_data, dilation_len)));
  )
}

tensor atg_thnn_conv_depthwise2d_out(tensor output, tensor self, tensor weight, int *kernel_size_data, int kernel_size_len, tensor bias, int *stride_data, int stride_len, int *padding_data, int padding_len, int *dilation_data, int dilation_len) {
  PROTECT(
    return new torch::Tensor(torch::thnn_conv_depthwise2d_out(*output, *self, *weight, of_carray(kernel_size_data, kernel_size_len), *bias, of_carray(stride_data, stride_len), of_carray(padding_data, padding_len), of_carray(dilation_data, dilation_len)));
  )
}

tensor atg_thnn_conv_dilated2d(tensor self, tensor weight, int *kernel_size_data, int kernel_size_len, tensor bias, int *stride_data, int stride_len, int *padding_data, int padding_len, int *dilation_data, int dilation_len) {
  PROTECT(
    return new torch::Tensor(torch::thnn_conv_dilated2d(*self, *weight, of_carray(kernel_size_data, kernel_size_len), *bias, of_carray(stride_data, stride_len), of_carray(padding_data, padding_len), of_carray(dilation_data, dilation_len)));
  )
}

tensor atg_thnn_conv_dilated2d_out(tensor output, tensor self, tensor weight, int *kernel_size_data, int kernel_size_len, tensor bias, int *stride_data, int stride_len, int *padding_data, int padding_len, int *dilation_data, int dilation_len) {
  PROTECT(
    return new torch::Tensor(torch::thnn_conv_dilated2d_out(*output, *self, *weight, of_carray(kernel_size_data, kernel_size_len), *bias, of_carray(stride_data, stride_len), of_carray(padding_data, padding_len), of_carray(dilation_data, dilation_len)));
  )
}

tensor atg_thnn_conv_dilated3d(tensor self, tensor weight, int *kernel_size_data, int kernel_size_len, tensor bias, int *stride_data, int stride_len, int *padding_data, int padding_len, int *dilation_data, int dilation_len) {
  PROTECT(
    return new torch::Tensor(torch::thnn_conv_dilated3d(*self, *weight, of_carray(kernel_size_data, kernel_size_len), *bias, of_carray(stride_data, stride_len), of_carray(padding_data, padding_len), of_carray(dilation_data, dilation_len)));
  )
}

tensor atg_thnn_conv_dilated3d_out(tensor output, tensor self, tensor weight, int *kernel_size_data, int kernel_size_len, tensor bias, int *stride_data, int stride_len, int *padding_data, int padding_len, int *dilation_data, int dilation_len) {
  PROTECT(
    return new torch::Tensor(torch::thnn_conv_dilated3d_out(*output, *self, *weight, of_carray(kernel_size_data, kernel_size_len), *bias, of_carray(stride_data, stride_len), of_carray(padding_data, padding_len), of_carray(dilation_data, dilation_len)));
  )
}

tensor atg_thnn_conv_transpose2d(tensor self, tensor weight, int *kernel_size_data, int kernel_size_len, tensor bias, int *stride_data, int stride_len, int *padding_data, int padding_len, int *output_padding_data, int output_padding_len, int *dilation_data, int dilation_len) {
  PROTECT(
    return new torch::Tensor(torch::thnn_conv_transpose2d(*self, *weight, of_carray(kernel_size_data, kernel_size_len), *bias, of_carray(stride_data, stride_len), of_carray(padding_data, padding_len), of_carray(output_padding_data, output_padding_len), of_carray(dilation_data, dilation_len)));
  )
}

tensor atg_thnn_conv_transpose2d_out(tensor output, tensor self, tensor weight, int *kernel_size_data, int kernel_size_len, tensor bias, int *stride_data, int stride_len, int *padding_data, int padding_len, int *output_padding_data, int output_padding_len, int *dilation_data, int dilation_len) {
  PROTECT(
    return new torch::Tensor(torch::thnn_conv_transpose2d_out(*output, *self, *weight, of_carray(kernel_size_data, kernel_size_len), *bias, of_carray(stride_data, stride_len), of_carray(padding_data, padding_len), of_carray(output_padding_data, output_padding_len), of_carray(dilation_data, dilation_len)));
  )
}

tensor atg_thnn_conv_transpose3d(tensor self, tensor weight, int *kernel_size_data, int kernel_size_len, tensor bias, int *stride_data, int stride_len, int *padding_data, int padding_len, int *output_padding_data, int output_padding_len, int *dilation_data, int dilation_len) {
  PROTECT(
    return new torch::Tensor(torch::thnn_conv_transpose3d(*self, *weight, of_carray(kernel_size_data, kernel_size_len), *bias, of_carray(stride_data, stride_len), of_carray(padding_data, padding_len), of_carray(output_padding_data, output_padding_len), of_carray(dilation_data, dilation_len)));
  )
}

tensor atg_thnn_conv_transpose3d_out(tensor output, tensor self, tensor weight, int *kernel_size_data, int kernel_size_len, tensor bias, int *stride_data, int stride_len, int *padding_data, int padding_len, int *output_padding_data, int output_padding_len, int *dilation_data, int dilation_len) {
  PROTECT(
    return new torch::Tensor(torch::thnn_conv_transpose3d_out(*output, *self, *weight, of_carray(kernel_size_data, kernel_size_len), *bias, of_carray(stride_data, stride_len), of_carray(padding_data, padding_len), of_carray(output_padding_data, output_padding_len), of_carray(dilation_data, dilation_len)));
  )
}

tensor atg_to1(tensor self, int device) {
  PROTECT(
    return new torch::Tensor(self->to(torch::Device(torch::DeviceType(device))));
  )
}

tensor atg_to2(tensor self, int device, int dtype, int non_blocking) {
  PROTECT(
    return new torch::Tensor(self->to(torch::Device(torch::DeviceType(device)), torch::ScalarType(dtype), (bool)non_blocking));
  )
}

tensor atg_to3(tensor self, int dtype, int non_blocking) {
  PROTECT(
    return new torch::Tensor(self->to(torch::ScalarType(dtype), (bool)non_blocking));
  )
}

tensor atg_to4(tensor self, int device, int non_blocking) {
  PROTECT(
    return new torch::Tensor(self->to(torch::Device(torch::DeviceType(device)), (bool)non_blocking));
  )
}

tensor atg_to5(tensor self, tensor other, int non_blocking) {
  PROTECT(
    return new torch::Tensor(self->to(*other, (bool)non_blocking));
  )
}

tensor atg_to_dense(tensor self) {
  PROTECT(
    return new torch::Tensor(self->to_dense());
  )
}

tensor atg_totype(tensor self, int scalar_type) {
  PROTECT(
    return new torch::Tensor(self->toType(torch::ScalarType(scalar_type)));
  )
}

tensor atg_transpose(tensor self, int64_t dim0, int64_t dim1) {
  PROTECT(
    return new torch::Tensor(torch::transpose(*self, dim0, dim1));
  )
}

tensor atg_transpose_(tensor self, int64_t dim0, int64_t dim1) {
  PROTECT(
    return new torch::Tensor(self->transpose_(dim0, dim1));
  )
}

tensor atg_tril(tensor self, int64_t diagonal) {
  PROTECT(
    return new torch::Tensor(torch::tril(*self, diagonal));
  )
}

tensor atg_tril_(tensor self, int64_t diagonal) {
  PROTECT(
    return new torch::Tensor(self->tril_(diagonal));
  )
}

tensor atg_tril_out(tensor result, tensor self, int64_t diagonal) {
  PROTECT(
    return new torch::Tensor(torch::tril_out(*result, *self, diagonal));
  )
}

tensor atg_triplet_margin_loss(tensor anchor, tensor positive, tensor negative, double margin, double p, double eps, int swap, int64_t reduction) {
  PROTECT(
    return new torch::Tensor(torch::triplet_margin_loss(*anchor, *positive, *negative, margin, p, eps, (bool)swap, reduction));
  )
}

tensor atg_triu(tensor self, int64_t diagonal) {
  PROTECT(
    return new torch::Tensor(torch::triu(*self, diagonal));
  )
}

tensor atg_triu_(tensor self, int64_t diagonal) {
  PROTECT(
    return new torch::Tensor(self->triu_(diagonal));
  )
}

tensor atg_triu_out(tensor result, tensor self, int64_t diagonal) {
  PROTECT(
    return new torch::Tensor(torch::triu_out(*result, *self, diagonal));
  )
}

tensor atg_trunc(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::trunc(*self));
  )
}

tensor atg_trunc_(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::trunc_(*self));
  )
}

tensor atg_trunc_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::trunc_out(*result, *self));
  )
}

tensor atg_type_as(tensor self, tensor other) {
  PROTECT(
    return new torch::Tensor(self->type_as(*other));
  )
}

tensor atg_unfold(tensor self, int64_t dimension, int64_t size, int64_t step) {
  PROTECT(
    return new torch::Tensor(self->unfold(dimension, size, step));
  )
}

tensor atg_uniform_(tensor self, double from, double to) {
  PROTECT(
    return new torch::Tensor(self->uniform_(from, to));
  )
}

tensor atg_unsqueeze(tensor self, int64_t dim) {
  PROTECT(
    return new torch::Tensor(torch::unsqueeze(*self, dim));
  )
}

tensor atg_unsqueeze_(tensor self, int64_t dim) {
  PROTECT(
    return new torch::Tensor(self->unsqueeze_(dim));
  )
}

tensor atg_upsample_bilinear2d(tensor self, int *output_size_data, int output_size_len, int align_corners) {
  PROTECT(
    return new torch::Tensor(torch::upsample_bilinear2d(*self, of_carray(output_size_data, output_size_len), (bool)align_corners));
  )
}

tensor atg_upsample_bilinear2d_backward(tensor grad_output, int *output_size_data, int output_size_len, int *input_size_data, int input_size_len, int align_corners) {
  PROTECT(
    return new torch::Tensor(torch::upsample_bilinear2d_backward(*grad_output, of_carray(output_size_data, output_size_len), of_carray(input_size_data, input_size_len), (bool)align_corners));
  )
}

tensor atg_upsample_bilinear2d_backward_out(tensor grad_input, tensor grad_output, int *output_size_data, int output_size_len, int *input_size_data, int input_size_len, int align_corners) {
  PROTECT(
    return new torch::Tensor(torch::upsample_bilinear2d_backward_out(*grad_input, *grad_output, of_carray(output_size_data, output_size_len), of_carray(input_size_data, input_size_len), (bool)align_corners));
  )
}

tensor atg_upsample_bilinear2d_forward(tensor self, int *output_size_data, int output_size_len, int align_corners) {
  PROTECT(
    return new torch::Tensor(torch::upsample_bilinear2d_forward(*self, of_carray(output_size_data, output_size_len), (bool)align_corners));
  )
}

tensor atg_upsample_bilinear2d_forward_out(tensor output, tensor self, int *output_size_data, int output_size_len, int align_corners) {
  PROTECT(
    return new torch::Tensor(torch::upsample_bilinear2d_forward_out(*output, *self, of_carray(output_size_data, output_size_len), (bool)align_corners));
  )
}

tensor atg_upsample_bilinear2d_out(tensor output, tensor self, int *output_size_data, int output_size_len, int align_corners) {
  PROTECT(
    return new torch::Tensor(torch::upsample_bilinear2d_out(*output, *self, of_carray(output_size_data, output_size_len), (bool)align_corners));
  )
}

tensor atg_upsample_linear1d(tensor self, int *output_size_data, int output_size_len, int align_corners) {
  PROTECT(
    return new torch::Tensor(torch::upsample_linear1d(*self, of_carray(output_size_data, output_size_len), (bool)align_corners));
  )
}

tensor atg_upsample_linear1d_backward(tensor grad_output, int *output_size_data, int output_size_len, int *input_size_data, int input_size_len, int align_corners) {
  PROTECT(
    return new torch::Tensor(torch::upsample_linear1d_backward(*grad_output, of_carray(output_size_data, output_size_len), of_carray(input_size_data, input_size_len), (bool)align_corners));
  )
}

tensor atg_upsample_linear1d_backward_out(tensor grad_input, tensor grad_output, int *output_size_data, int output_size_len, int *input_size_data, int input_size_len, int align_corners) {
  PROTECT(
    return new torch::Tensor(torch::upsample_linear1d_backward_out(*grad_input, *grad_output, of_carray(output_size_data, output_size_len), of_carray(input_size_data, input_size_len), (bool)align_corners));
  )
}

tensor atg_upsample_linear1d_forward(tensor self, int *output_size_data, int output_size_len, int align_corners) {
  PROTECT(
    return new torch::Tensor(torch::upsample_linear1d_forward(*self, of_carray(output_size_data, output_size_len), (bool)align_corners));
  )
}

tensor atg_upsample_linear1d_forward_out(tensor output, tensor self, int *output_size_data, int output_size_len, int align_corners) {
  PROTECT(
    return new torch::Tensor(torch::upsample_linear1d_forward_out(*output, *self, of_carray(output_size_data, output_size_len), (bool)align_corners));
  )
}

tensor atg_upsample_linear1d_out(tensor output, tensor self, int *output_size_data, int output_size_len, int align_corners) {
  PROTECT(
    return new torch::Tensor(torch::upsample_linear1d_out(*output, *self, of_carray(output_size_data, output_size_len), (bool)align_corners));
  )
}

tensor atg_upsample_nearest1d(tensor self, int *output_size_data, int output_size_len) {
  PROTECT(
    return new torch::Tensor(torch::upsample_nearest1d(*self, of_carray(output_size_data, output_size_len)));
  )
}

tensor atg_upsample_nearest1d_backward(tensor grad_output, int *output_size_data, int output_size_len, int *input_size_data, int input_size_len) {
  PROTECT(
    return new torch::Tensor(torch::upsample_nearest1d_backward(*grad_output, of_carray(output_size_data, output_size_len), of_carray(input_size_data, input_size_len)));
  )
}

tensor atg_upsample_nearest1d_backward_out(tensor grad_input, tensor grad_output, int *output_size_data, int output_size_len, int *input_size_data, int input_size_len) {
  PROTECT(
    return new torch::Tensor(torch::upsample_nearest1d_backward_out(*grad_input, *grad_output, of_carray(output_size_data, output_size_len), of_carray(input_size_data, input_size_len)));
  )
}

tensor atg_upsample_nearest1d_forward(tensor self, int *output_size_data, int output_size_len) {
  PROTECT(
    return new torch::Tensor(torch::upsample_nearest1d_forward(*self, of_carray(output_size_data, output_size_len)));
  )
}

tensor atg_upsample_nearest1d_forward_out(tensor output, tensor self, int *output_size_data, int output_size_len) {
  PROTECT(
    return new torch::Tensor(torch::upsample_nearest1d_forward_out(*output, *self, of_carray(output_size_data, output_size_len)));
  )
}

tensor atg_upsample_nearest1d_out(tensor output, tensor self, int *output_size_data, int output_size_len) {
  PROTECT(
    return new torch::Tensor(torch::upsample_nearest1d_out(*output, *self, of_carray(output_size_data, output_size_len)));
  )
}

tensor atg_upsample_nearest2d(tensor self, int *output_size_data, int output_size_len) {
  PROTECT(
    return new torch::Tensor(torch::upsample_nearest2d(*self, of_carray(output_size_data, output_size_len)));
  )
}

tensor atg_upsample_nearest2d_backward(tensor grad_output, int *output_size_data, int output_size_len, int *input_size_data, int input_size_len) {
  PROTECT(
    return new torch::Tensor(torch::upsample_nearest2d_backward(*grad_output, of_carray(output_size_data, output_size_len), of_carray(input_size_data, input_size_len)));
  )
}

tensor atg_upsample_nearest2d_backward_out(tensor grad_input, tensor grad_output, int *output_size_data, int output_size_len, int *input_size_data, int input_size_len) {
  PROTECT(
    return new torch::Tensor(torch::upsample_nearest2d_backward_out(*grad_input, *grad_output, of_carray(output_size_data, output_size_len), of_carray(input_size_data, input_size_len)));
  )
}

tensor atg_upsample_nearest2d_forward(tensor self, int *output_size_data, int output_size_len) {
  PROTECT(
    return new torch::Tensor(torch::upsample_nearest2d_forward(*self, of_carray(output_size_data, output_size_len)));
  )
}

tensor atg_upsample_nearest2d_forward_out(tensor output, tensor self, int *output_size_data, int output_size_len) {
  PROTECT(
    return new torch::Tensor(torch::upsample_nearest2d_forward_out(*output, *self, of_carray(output_size_data, output_size_len)));
  )
}

tensor atg_upsample_nearest2d_out(tensor output, tensor self, int *output_size_data, int output_size_len) {
  PROTECT(
    return new torch::Tensor(torch::upsample_nearest2d_out(*output, *self, of_carray(output_size_data, output_size_len)));
  )
}

tensor atg_upsample_nearest3d(tensor self, int *output_size_data, int output_size_len) {
  PROTECT(
    return new torch::Tensor(torch::upsample_nearest3d(*self, of_carray(output_size_data, output_size_len)));
  )
}

tensor atg_upsample_nearest3d_backward(tensor grad_output, int *output_size_data, int output_size_len, int *input_size_data, int input_size_len) {
  PROTECT(
    return new torch::Tensor(torch::upsample_nearest3d_backward(*grad_output, of_carray(output_size_data, output_size_len), of_carray(input_size_data, input_size_len)));
  )
}

tensor atg_upsample_nearest3d_backward_out(tensor grad_input, tensor grad_output, int *output_size_data, int output_size_len, int *input_size_data, int input_size_len) {
  PROTECT(
    return new torch::Tensor(torch::upsample_nearest3d_backward_out(*grad_input, *grad_output, of_carray(output_size_data, output_size_len), of_carray(input_size_data, input_size_len)));
  )
}

tensor atg_upsample_nearest3d_forward(tensor self, int *output_size_data, int output_size_len) {
  PROTECT(
    return new torch::Tensor(torch::upsample_nearest3d_forward(*self, of_carray(output_size_data, output_size_len)));
  )
}

tensor atg_upsample_nearest3d_forward_out(tensor output, tensor self, int *output_size_data, int output_size_len) {
  PROTECT(
    return new torch::Tensor(torch::upsample_nearest3d_forward_out(*output, *self, of_carray(output_size_data, output_size_len)));
  )
}

tensor atg_upsample_nearest3d_out(tensor output, tensor self, int *output_size_data, int output_size_len) {
  PROTECT(
    return new torch::Tensor(torch::upsample_nearest3d_out(*output, *self, of_carray(output_size_data, output_size_len)));
  )
}

tensor atg_upsample_trilinear3d(tensor self, int *output_size_data, int output_size_len, int align_corners) {
  PROTECT(
    return new torch::Tensor(torch::upsample_trilinear3d(*self, of_carray(output_size_data, output_size_len), (bool)align_corners));
  )
}

tensor atg_upsample_trilinear3d_backward(tensor grad_output, int *output_size_data, int output_size_len, int *input_size_data, int input_size_len, int align_corners) {
  PROTECT(
    return new torch::Tensor(torch::upsample_trilinear3d_backward(*grad_output, of_carray(output_size_data, output_size_len), of_carray(input_size_data, input_size_len), (bool)align_corners));
  )
}

tensor atg_upsample_trilinear3d_backward_out(tensor grad_input, tensor grad_output, int *output_size_data, int output_size_len, int *input_size_data, int input_size_len, int align_corners) {
  PROTECT(
    return new torch::Tensor(torch::upsample_trilinear3d_backward_out(*grad_input, *grad_output, of_carray(output_size_data, output_size_len), of_carray(input_size_data, input_size_len), (bool)align_corners));
  )
}

tensor atg_upsample_trilinear3d_forward(tensor self, int *output_size_data, int output_size_len, int align_corners) {
  PROTECT(
    return new torch::Tensor(torch::upsample_trilinear3d_forward(*self, of_carray(output_size_data, output_size_len), (bool)align_corners));
  )
}

tensor atg_upsample_trilinear3d_forward_out(tensor output, tensor self, int *output_size_data, int output_size_len, int align_corners) {
  PROTECT(
    return new torch::Tensor(torch::upsample_trilinear3d_forward_out(*output, *self, of_carray(output_size_data, output_size_len), (bool)align_corners));
  )
}

tensor atg_upsample_trilinear3d_out(tensor output, tensor self, int *output_size_data, int output_size_len, int align_corners) {
  PROTECT(
    return new torch::Tensor(torch::upsample_trilinear3d_out(*output, *self, of_carray(output_size_data, output_size_len), (bool)align_corners));
  )
}

tensor atg_var1(tensor self, int unbiased) {
  PROTECT(
    return new torch::Tensor(torch::var(*self, (bool)unbiased));
  )
}

tensor atg_var2(tensor self, int64_t dim, int unbiased, int keepdim) {
  PROTECT(
    return new torch::Tensor(torch::var(*self, dim, (bool)unbiased, (bool)keepdim));
  )
}

tensor atg_var_out(tensor result, tensor self, int64_t dim, int unbiased, int keepdim) {
  PROTECT(
    return new torch::Tensor(torch::var_out(*result, *self, dim, (bool)unbiased, (bool)keepdim));
  )
}

tensor atg_view(tensor self, int *size_data, int size_len) {
  PROTECT(
    return new torch::Tensor(self->view(of_carray(size_data, size_len)));
  )
}

tensor atg_view_as(tensor self, tensor other) {
  PROTECT(
    return new torch::Tensor(self->view_as(*other));
  )
}

tensor atg_zero_(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::zero_(*self));
  )
}

tensor atg_zeros(int *size_data, int size_len, int options) {
  PROTECT(
    return new torch::Tensor(torch::zeros(of_carray(size_data, size_len), torch::ScalarType(options)));
  )
}

tensor atg_zeros_like1(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::zeros_like(*self));
  )
}

tensor atg_zeros_like2(tensor self, int options) {
  PROTECT(
    return new torch::Tensor(torch::zeros_like(*self, torch::ScalarType(options)));
  )
}

tensor atg_zeros_out(tensor result, int *size_data, int size_len) {
  PROTECT(
    return new torch::Tensor(torch::zeros_out(*result, of_carray(size_data, size_len)));
  )
}

