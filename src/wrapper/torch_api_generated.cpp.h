
// THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT BY HAND!

tensor atg_RoiPooling2d_backward(tensor input, tensor rois, int64_t pooledHeight, int64_t pooledWidth, double spatialScale, tensor gradOutput, tensor argmaxes) {
  PROTECT(
    return new torch::Tensor(torch::RoiPooling2d_backward(*input, *rois, pooledHeight, pooledWidth, spatialScale, *gradOutput, *argmaxes));
  )
}

tensor atg_abs_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::abs_out(*result, *self));
  )
}

tensor atg_acos_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::acos_out(*result, *self));
  )
}

tensor atg_add_out(tensor result, tensor self, tensor other) {
  PROTECT(
    return new torch::Tensor(torch::add_out(*result, *self, *other));
  )
}

tensor atg_addmm_out(tensor result, tensor self, tensor mat1, tensor mat2) {
  PROTECT(
    return new torch::Tensor(torch::addmm_out(*result, *self, *mat1, *mat2));
  )
}

tensor atg_addmv_out(tensor result, tensor self, tensor mat, tensor vec) {
  PROTECT(
    return new torch::Tensor(torch::addmv_out(*result, *self, *mat, *vec));
  )
}

tensor atg_addr_out(tensor result, tensor self, tensor vec1, tensor vec2) {
  PROTECT(
    return new torch::Tensor(torch::addr_out(*result, *self, *vec1, *vec2));
  )
}

tensor atg_all_out(tensor result, tensor self, int64_t dim, int keepdim) {
  PROTECT(
    return new torch::Tensor(torch::all_out(*result, *self, dim, keepdim));
  )
}

tensor atg_alpha_dropout(tensor input, double p, int train) {
  PROTECT(
    return new torch::Tensor(torch::alpha_dropout(*input, p, train));
  )
}

tensor atg_alpha_dropout_(tensor self, double p, int train) {
  PROTECT(
    return new torch::Tensor(torch::alpha_dropout_(*self, p, train));
  )
}

tensor atg_any_out(tensor result, tensor self, int64_t dim, int keepdim) {
  PROTECT(
    return new torch::Tensor(torch::any_out(*result, *self, dim, keepdim));
  )
}

tensor atg_asin_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::asin_out(*result, *self));
  )
}

tensor atg_atan_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::atan_out(*result, *self));
  )
}

tensor atg_baddbmm_out(tensor result, tensor self, tensor batch1, tensor batch2) {
  PROTECT(
    return new torch::Tensor(torch::baddbmm_out(*result, *self, *batch1, *batch2));
  )
}

tensor atg_bartlett_window1(int64_t window_length) {
  PROTECT(
    return new torch::Tensor(torch::bartlett_window(window_length));
  )
}

tensor atg_bartlett_window2(int64_t window_length, int periodic) {
  PROTECT(
    return new torch::Tensor(torch::bartlett_window(window_length, periodic));
  )
}

tensor atg_bernoulli_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::bernoulli_out(*result, *self));
  )
}

tensor atg_blackman_window1(int64_t window_length) {
  PROTECT(
    return new torch::Tensor(torch::blackman_window(window_length));
  )
}

tensor atg_blackman_window2(int64_t window_length, int periodic) {
  PROTECT(
    return new torch::Tensor(torch::blackman_window(window_length, periodic));
  )
}

tensor atg_bmm_out(tensor result, tensor self, tensor mat2) {
  PROTECT(
    return new torch::Tensor(torch::bmm_out(*result, *self, *mat2));
  )
}

tensor atg_ceil_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::ceil_out(*result, *self));
  )
}

tensor atg_celu(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::celu(*self));
  )
}

tensor atg_celu_(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::celu_(*self));
  )
}

tensor atg_conv1d(tensor input, tensor weight, tensor bias, int64_t groups) {
  PROTECT(
    return new torch::Tensor(torch::conv1d(*input, *weight, *bias, groups));
  )
}

tensor atg_conv2d(tensor input, tensor weight, tensor bias, int64_t groups) {
  PROTECT(
    return new torch::Tensor(torch::conv2d(*input, *weight, *bias, groups));
  )
}

tensor atg_conv3d(tensor input, tensor weight, tensor bias, int64_t groups) {
  PROTECT(
    return new torch::Tensor(torch::conv3d(*input, *weight, *bias, groups));
  )
}

tensor atg_conv_tbc(tensor self, tensor weight, tensor bias, int64_t pad) {
  PROTECT(
    return new torch::Tensor(torch::conv_tbc(*self, *weight, *bias, pad));
  )
}

tensor atg_conv_transpose1d(tensor input, tensor weight, tensor bias, int64_t groups) {
  PROTECT(
    return new torch::Tensor(torch::conv_transpose1d(*input, *weight, *bias, groups));
  )
}

tensor atg_conv_transpose2d(tensor input, tensor weight, tensor bias, int64_t groups) {
  PROTECT(
    return new torch::Tensor(torch::conv_transpose2d(*input, *weight, *bias, groups));
  )
}

tensor atg_conv_transpose3d(tensor input, tensor weight, tensor bias, int64_t groups) {
  PROTECT(
    return new torch::Tensor(torch::conv_transpose3d(*input, *weight, *bias, groups));
  )
}

tensor atg_copy_sparse_to_sparse_(tensor self, tensor src, int non_blocking) {
  PROTECT(
    return new torch::Tensor(torch::copy_sparse_to_sparse_(*self, *src, non_blocking));
  )
}

tensor atg_cos_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::cos_out(*result, *self));
  )
}

tensor atg_cosh_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::cosh_out(*result, *self));
  )
}

tensor atg_cosine_embedding_loss(tensor input1, tensor input2, tensor target, double margin, int64_t reduction) {
  PROTECT(
    return new torch::Tensor(torch::cosine_embedding_loss(*input1, *input2, *target, margin, reduction));
  )
}

tensor atg_ctc_loss2(tensor log_probs, tensor targets, tensor input_lengths, tensor target_lengths, int64_t blank, int64_t reduction) {
  PROTECT(
    return new torch::Tensor(torch::ctc_loss(*log_probs, *targets, *input_lengths, *target_lengths, blank, reduction));
  )
}

tensor atg_cudnn_affine_grid_generator(tensor theta, int64_t N, int64_t C, int64_t H, int64_t W) {
  PROTECT(
    return new torch::Tensor(torch::cudnn_affine_grid_generator(*theta, N, C, H, W));
  )
}

tensor atg_cudnn_convolution_backward_bias(tensor grad_output) {
  PROTECT(
    return new torch::Tensor(torch::cudnn_convolution_backward_bias(*grad_output));
  )
}

tensor atg_cudnn_convolution_transpose_backward_bias(tensor grad_output) {
  PROTECT(
    return new torch::Tensor(torch::cudnn_convolution_transpose_backward_bias(*grad_output));
  )
}

tensor atg_cumprod_out2(tensor result, tensor self, int64_t dim) {
  PROTECT(
    return new torch::Tensor(torch::cumprod_out(*result, *self, dim));
  )
}

tensor atg_cumsum_out2(tensor result, tensor self, int64_t dim) {
  PROTECT(
    return new torch::Tensor(torch::cumsum_out(*result, *self, dim));
  )
}

tensor atg_div_out(tensor result, tensor self, tensor other) {
  PROTECT(
    return new torch::Tensor(torch::div_out(*result, *self, *other));
  )
}

tensor atg_dot_out(tensor result, tensor self, tensor tensor) {
  PROTECT(
    return new torch::Tensor(torch::dot_out(*result, *self, *tensor));
  )
}

tensor atg_dropout(tensor input, double p, int train) {
  PROTECT(
    return new torch::Tensor(torch::dropout(*input, p, train));
  )
}

tensor atg_dropout_(tensor self, double p, int train) {
  PROTECT(
    return new torch::Tensor(torch::dropout_(*self, p, train));
  )
}

tensor atg_empty_like1(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::empty_like(*self));
  )
}

tensor atg_erf_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::erf_out(*result, *self));
  )
}

tensor atg_erfc_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::erfc_out(*result, *self));
  )
}

tensor atg_exp_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::exp_out(*result, *self));
  )
}

tensor atg_expm1_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::expm1_out(*result, *self));
  )
}

tensor atg_eye1(int64_t n) {
  PROTECT(
    return new torch::Tensor(torch::eye(n));
  )
}

tensor atg_eye2(int64_t n, int64_t m) {
  PROTECT(
    return new torch::Tensor(torch::eye(n, m));
  )
}

tensor atg_eye_out1(tensor result, int64_t n) {
  PROTECT(
    return new torch::Tensor(torch::eye_out(*result, n));
  )
}

tensor atg_eye_out2(tensor result, int64_t n, int64_t m) {
  PROTECT(
    return new torch::Tensor(torch::eye_out(*result, n, m));
  )
}

tensor atg_feature_alpha_dropout(tensor input, double p, int train) {
  PROTECT(
    return new torch::Tensor(torch::feature_alpha_dropout(*input, p, train));
  )
}

tensor atg_feature_alpha_dropout_(tensor self, double p, int train) {
  PROTECT(
    return new torch::Tensor(torch::feature_alpha_dropout_(*self, p, train));
  )
}

tensor atg_feature_dropout(tensor input, double p, int train) {
  PROTECT(
    return new torch::Tensor(torch::feature_dropout(*input, p, train));
  )
}

tensor atg_feature_dropout_(tensor self, double p, int train) {
  PROTECT(
    return new torch::Tensor(torch::feature_dropout_(*self, p, train));
  )
}

tensor atg_floor_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::floor_out(*result, *self));
  )
}

tensor atg_frobenius_norm1(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::frobenius_norm(*self));
  )
}

tensor atg_ger_out(tensor result, tensor self, tensor vec2) {
  PROTECT(
    return new torch::Tensor(torch::ger_out(*result, *self, *vec2));
  )
}

tensor atg_grid_sampler(tensor input, tensor grid, int64_t interpolation_mode, int64_t padding_mode) {
  PROTECT(
    return new torch::Tensor(torch::grid_sampler(*input, *grid, interpolation_mode, padding_mode));
  )
}

tensor atg_grid_sampler_2d(tensor input, tensor grid, int64_t interpolation_mode, int64_t padding_mode) {
  PROTECT(
    return new torch::Tensor(torch::grid_sampler_2d(*input, *grid, interpolation_mode, padding_mode));
  )
}

tensor atg_grid_sampler_3d(tensor input, tensor grid, int64_t interpolation_mode, int64_t padding_mode) {
  PROTECT(
    return new torch::Tensor(torch::grid_sampler_3d(*input, *grid, interpolation_mode, padding_mode));
  )
}

tensor atg_gru_cell(tensor input, tensor hx, tensor w_ih, tensor w_hh) {
  PROTECT(
    return new torch::Tensor(torch::gru_cell(*input, *hx, *w_ih, *w_hh));
  )
}

tensor atg_hamming_window1(int64_t window_length) {
  PROTECT(
    return new torch::Tensor(torch::hamming_window(window_length));
  )
}

tensor atg_hamming_window2(int64_t window_length, int periodic) {
  PROTECT(
    return new torch::Tensor(torch::hamming_window(window_length, periodic));
  )
}

tensor atg_hamming_window3(int64_t window_length, int periodic, double alpha) {
  PROTECT(
    return new torch::Tensor(torch::hamming_window(window_length, periodic, alpha));
  )
}

tensor atg_hamming_window4(int64_t window_length, int periodic, double alpha, double beta) {
  PROTECT(
    return new torch::Tensor(torch::hamming_window(window_length, periodic, alpha, beta));
  )
}

tensor atg_hann_window1(int64_t window_length) {
  PROTECT(
    return new torch::Tensor(torch::hann_window(window_length));
  )
}

tensor atg_hann_window2(int64_t window_length, int periodic) {
  PROTECT(
    return new torch::Tensor(torch::hann_window(window_length, periodic));
  )
}

tensor atg_hinge_embedding_loss(tensor self, tensor target, double margin, int64_t reduction) {
  PROTECT(
    return new torch::Tensor(torch::hinge_embedding_loss(*self, *target, margin, reduction));
  )
}

tensor atg_hspmm(tensor mat1, tensor mat2) {
  PROTECT(
    return new torch::Tensor(torch::hspmm(*mat1, *mat2));
  )
}

tensor atg_hspmm_out(tensor result, tensor mat1, tensor mat2) {
  PROTECT(
    return new torch::Tensor(torch::hspmm_out(*result, *mat1, *mat2));
  )
}

tensor atg_inverse_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::inverse_out(*result, *self));
  )
}

tensor atg_kl_div(tensor self, tensor target, int64_t reduction) {
  PROTECT(
    return new torch::Tensor(torch::kl_div(*self, *target, reduction));
  )
}

tensor atg_kl_div_backward(tensor grad_output, tensor self, tensor target, int64_t reduction) {
  PROTECT(
    return new torch::Tensor(torch::kl_div_backward(*grad_output, *self, *target, reduction));
  )
}

tensor atg_linear(tensor input, tensor weight, tensor bias) {
  PROTECT(
    return new torch::Tensor(torch::linear(*input, *weight, *bias));
  )
}

tensor atg_log10_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::log10_out(*result, *self));
  )
}

tensor atg_log1p_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::log1p_out(*result, *self));
  )
}

tensor atg_log2_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::log2_out(*result, *self));
  )
}

tensor atg_log_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::log_out(*result, *self));
  )
}

tensor atg_log_softmax_backward_data(tensor grad_output, tensor output, int64_t dim, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::log_softmax_backward_data(*grad_output, *output, dim, *self));
  )
}

tensor atg_logsumexp_out(tensor result, tensor self, int64_t dim, int keepdim) {
  PROTECT(
    return new torch::Tensor(torch::logsumexp_out(*result, *self, dim, keepdim));
  )
}

tensor atg_margin_ranking_loss(tensor input1, tensor input2, tensor target, double margin, int64_t reduction) {
  PROTECT(
    return new torch::Tensor(torch::margin_ranking_loss(*input1, *input2, *target, margin, reduction));
  )
}

tensor atg_matmul_out(tensor result, tensor self, tensor other) {
  PROTECT(
    return new torch::Tensor(torch::matmul_out(*result, *self, *other));
  )
}

tensor atg_mean_out2(tensor result, tensor self, int64_t dim, int keepdim) {
  PROTECT(
    return new torch::Tensor(torch::mean_out(*result, *self, dim, keepdim));
  )
}

tensor atg_miopen_convolution_backward_bias(tensor grad_output) {
  PROTECT(
    return new torch::Tensor(torch::miopen_convolution_backward_bias(*grad_output));
  )
}

tensor atg_mm_out(tensor result, tensor self, tensor mat2) {
  PROTECT(
    return new torch::Tensor(torch::mm_out(*result, *self, *mat2));
  )
}

tensor atg_mul_out(tensor result, tensor self, tensor other) {
  PROTECT(
    return new torch::Tensor(torch::mul_out(*result, *self, *other));
  )
}

tensor atg_mv_out(tensor result, tensor self, tensor vec) {
  PROTECT(
    return new torch::Tensor(torch::mv_out(*result, *self, *vec));
  )
}

tensor atg_native_clone(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::native_clone(*self));
  )
}

tensor atg_native_norm(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::native_norm(*self));
  )
}

tensor atg_native_resize_as_(tensor self, tensor the_template) {
  PROTECT(
    return new torch::Tensor(torch::native_resize_as_(*self, *the_template));
  )
}

tensor atg_native_zero_(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::native_zero_(*self));
  )
}

tensor atg_norm_except_dim(tensor v, int64_t pow, int64_t dim) {
  PROTECT(
    return new torch::Tensor(torch::norm_except_dim(*v, pow, dim));
  )
}

tensor atg_nuclear_norm(tensor self, int keepdim) {
  PROTECT(
    return new torch::Tensor(torch::nuclear_norm(*self, keepdim));
  )
}

tensor atg_nuclear_norm_out(tensor result, tensor self, int keepdim) {
  PROTECT(
    return new torch::Tensor(torch::nuclear_norm_out(*result, *self, keepdim));
  )
}

tensor atg_ones_like1(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::ones_like(*self));
  )
}

tensor atg_pairwise_distance(tensor x1, tensor x2, double p, double eps, int keepdim) {
  PROTECT(
    return new torch::Tensor(torch::pairwise_distance(*x1, *x2, p, eps, keepdim));
  )
}

tensor atg_pdist(tensor self, double p) {
  PROTECT(
    return new torch::Tensor(torch::pdist(*self, p));
  )
}

tensor atg_pixel_shuffle(tensor self, int64_t upscale_factor) {
  PROTECT(
    return new torch::Tensor(torch::pixel_shuffle(*self, upscale_factor));
  )
}

tensor atg_poisson(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::poisson(*self));
  )
}

tensor atg_prod_out2(tensor result, tensor self, int64_t dim, int keepdim) {
  PROTECT(
    return new torch::Tensor(torch::prod_out(*result, *self, dim, keepdim));
  )
}

tensor atg_rand_like1(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::rand_like(*self));
  )
}

tensor atg_randint_like1(tensor self, int64_t high) {
  PROTECT(
    return new torch::Tensor(torch::randint_like(*self, high));
  )
}

tensor atg_randint_like2(tensor self, int64_t low, int64_t high) {
  PROTECT(
    return new torch::Tensor(torch::randint_like(*self, low, high));
  )
}

tensor atg_randn_like1(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::randn_like(*self));
  )
}

tensor atg_randperm1(int64_t n) {
  PROTECT(
    return new torch::Tensor(torch::randperm(n));
  )
}

tensor atg_randperm_out1(tensor result, int64_t n) {
  PROTECT(
    return new torch::Tensor(torch::randperm_out(*result, n));
  )
}

tensor atg_rnn_relu_cell(tensor input, tensor hx, tensor w_ih, tensor w_hh) {
  PROTECT(
    return new torch::Tensor(torch::rnn_relu_cell(*input, *hx, *w_ih, *w_hh));
  )
}

tensor atg_rnn_tanh_cell(tensor input, tensor hx, tensor w_ih, tensor w_hh) {
  PROTECT(
    return new torch::Tensor(torch::rnn_tanh_cell(*input, *hx, *w_ih, *w_hh));
  )
}

tensor atg_round_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::round_out(*result, *self));
  )
}

tensor atg_rrelu(tensor self, int training) {
  PROTECT(
    return new torch::Tensor(torch::rrelu(*self, training));
  )
}

tensor atg_rrelu_(tensor self, int training) {
  PROTECT(
    return new torch::Tensor(torch::rrelu_(*self, training));
  )
}

tensor atg_rsqrt_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::rsqrt_out(*result, *self));
  )
}

tensor atg_s_native_addmm(tensor self, tensor mat1, tensor mat2) {
  PROTECT(
    return new torch::Tensor(torch::s_native_addmm(*self, *mat1, *mat2));
  )
}

tensor atg_s_native_addmm_(tensor self, tensor mat1, tensor mat2) {
  PROTECT(
    return new torch::Tensor(torch::s_native_addmm_(*self, *mat1, *mat2));
  )
}

tensor atg_s_native_addmm_out(tensor result, tensor self, tensor mat1, tensor mat2) {
  PROTECT(
    return new torch::Tensor(torch::s_native_addmm_out(*result, *self, *mat1, *mat2));
  )
}

tensor atg_selu(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::selu(*self));
  )
}

tensor atg_selu_(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::selu_(*self));
  )
}

tensor atg_sigmoid_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::sigmoid_out(*result, *self));
  )
}

tensor atg_sin_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::sin_out(*result, *self));
  )
}

tensor atg_sinh_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::sinh_out(*result, *self));
  )
}

tensor atg_softmax_backward_data(tensor grad_output, tensor output, int64_t dim, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::softmax_backward_data(*grad_output, *output, dim, *self));
  )
}

tensor atg_sqrt_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::sqrt_out(*result, *self));
  )
}

tensor atg_sspaddmm_out(tensor result, tensor self, tensor mat1, tensor mat2) {
  PROTECT(
    return new torch::Tensor(torch::sspaddmm_out(*result, *self, *mat1, *mat2));
  )
}

tensor atg_std_out(tensor result, tensor self, int64_t dim, int unbiased, int keepdim) {
  PROTECT(
    return new torch::Tensor(torch::std_out(*result, *self, dim, unbiased, keepdim));
  )
}

tensor atg_sub_out(tensor result, tensor self, tensor other) {
  PROTECT(
    return new torch::Tensor(torch::sub_out(*result, *self, *other));
  )
}

tensor atg_tan_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::tan_out(*result, *self));
  )
}

tensor atg_tanh_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::tanh_out(*result, *self));
  )
}

tensor atg_triplet_margin_loss(tensor anchor, tensor positive, tensor negative, double margin, double p, double eps, int swap, int64_t reduction) {
  PROTECT(
    return new torch::Tensor(torch::triplet_margin_loss(*anchor, *positive, *negative, margin, p, eps, swap, reduction));
  )
}

tensor atg_trunc_out(tensor result, tensor self) {
  PROTECT(
    return new torch::Tensor(torch::trunc_out(*result, *self));
  )
}

tensor atg_var_out(tensor result, tensor self, int64_t dim, int unbiased, int keepdim) {
  PROTECT(
    return new torch::Tensor(torch::var_out(*result, *self, dim, unbiased, keepdim));
  )
}

tensor atg_zeros_like1(tensor self) {
  PROTECT(
    return new torch::Tensor(torch::zeros_like(*self));
  )
}

